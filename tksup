#!/usr/bin/tclsh
#
package require Expect
package require Tk

puts "argv($argv)"

# CVS revision information for information dialog
set revision {$Revision$}
set revDate {$Date$}

# Michael Akdeniz 1999
# Moon Yi - modified subsequent changes since April 2001
# Stephen BRUCE - more hacks for multicast environment
# Michael Dodd - fixing all their bugs ;) 2004

# This script provides the front end of the Techical Supervision
# It provides some access to UBSS specific tools as well as in-house
# developed monitoring tools

# Debuging flag to show procedure names
# debugTrace 0 -> off
# debugTrace 1 -> on
# debugTrace 2 -> excessive
set debugTrace 0

# ==========================================================================
# execution environment setup
# ==========================================================================

proc dputs { msg } {
  global debugTrace
  if { $debugTrace > 0 } {
    puts $msg
  }
}

if { $debugTrace == 2 } {
  rename proc _proc
  _proc proc {name arglist body} {
    _proc $name $arglist [concat "proc_start;" $body ";proc_end"]
  }
  _proc proc_start {} {
    puts stderr ">>> ENTER PROC [lindex [info level -1] 0]"
    for {set level [expr [info level] -1]} {$level > 0} {incr level -1} {
      puts stderr "  LEVEL $level: [info level $level]"
    }
    puts stderr ""
  }
  _proc proc_end {} {
    puts stderr ">>> LEAVE PROC [lindex [info level -1] 0]\n"
  }
}

#-----------------------------------------------------------------------------
# Define display attributes in associative arrays
# node states (from bs.h)
#-----------------------------------------------------------------------------

proc defineColorStateAttributes {} {
   global color state 

   dputs "### defineColorStateAttributes:"
   set color(2_20) white
   set color(2_21) yellow
   set color(2_22) gray
   set color(2_23) green
   set color(2_24) orange
   set color(2_25) purple
   set color(2_26) red
   set color(2_27) cyan
   
   # dual node states
   set state(3_50) "DNCOFFLINE     "
   set state(3_51) "DNCSINGLE      "
   set state(3_52) "DNCMASTER      "
   set state(3_53) "DNCSLAVE       "
   set state(3_54) "DNCNOTAVAILABLE"
   set state(3_55) "DNCRUNDOWN     "
   set state(3_56) "UNKNOWN        "
   
   #node states
   set state(2_20) "OFFLINE     "
   set state(2_21) "STARTING    "
   set state(2_22) "SUSPEND     "
   set state(2_23) "ONLINE      "
   set state(2_24) "SHUTDOWN    "
   set state(2_25) "RESIDENTONLY"
   set state(2_26) "EXITED      "
   set state(2_27) "UNKNOWN     "

   # Special case just for MMI
   set state(4_40) "OFFLINE    "
   set state(4_41) "STARTING   "
   set state(4_42) "ONLINE     "
   set state(4_43) "SHUTDOWN   "
   set state(4_44) "EXITED     "
   set state(4_45) "UNKNOWN    "

   # Special case just for MMI
   set color(4_40) white
   set color(4_41) yellow
   set color(4_42) green
   set color(4_43) orange
   set color(4_44) red
   set color(4_45) cyan
   
   #device colors
   set color(4_100) green
   set color(4_101) red
   set color(4_102) cyan
   set color(4_103) green
   set color(4_104) gray
   set color(4_105) gray
   set color(4_106) purple
   set color(4_107) yellow
   set color(4_108) brown
   set color(4_109) green
   set color(4_110) green
   set color(4_111) green
   set color(4_112) orange

   #device states
   set state(4_100) "OK         "
   set state(4_101) "FAILED     "
   set state(4_102) "UNKNOWN    "
   set state(4_103) "IN USE     "
   set state(4_104) "MAINTHALT  "
   set state(4_105) "MAINTOFF   "
   set state(4_106) "DETACHED   "
   set state(4_107) "STARTING   "
   set state(4_108) "STANDBY    "
   set state(4_109) "OPERATIONAL"
   set state(4_110) "TRANSMIT   "
   set state(4_111) "READY      "
   set state(4_112) "NOT OK     "

   #default message log colors, these are set when the message log is created
   set color(I)     black
   set color(W)     yellow
   set color(F)     red
}

#-----------------------------------------------------------------------------
# procedure usage
#-----------------------------------------------------------------------------

proc usage {} {
  global  exe_name

  puts "
Usage:  $exe_name -part partname -m mcastaddr -p portisupc -r portisupr -t porttoken -i mcastiface

$exe_name is a Thales TopSky-ATC(HE) partition technical supervision utility. It can 
monitor and control a single partition only.

    where:   -part partname    is 4 letter parttition name, eg., TSER (optional)
             -m mcastaddr      multicast IP address to use
             -i mcastiface     this node's interface to use for the multicast traffic
             -t porttoken      token exchange port
             -r portisupc      ISUP command port
             -p portisupr      ISUP response port
	     -q centralnode    central node(s) of this partition
             -D                Turn on debug tracing (optional)
"
   exit
}


#-----------------------------------------------------------------------------

proc parseArgv { } {
   global partname portisupc portisupr porttoken mcastaddr mcastiface argv debugTrace centralnode

   puts "# argv = \"$argv\""
   set state flag
   foreach arg $argv {
      switch -- $state {
         flag {
            switch -glob -- $arg {
               -part {set state partname}
               -m {set state mcastaddr}
               -r {set state portisupc}
               -t {set state porttoken}
               -p {set state portisupr}
               -i {set state mcastiface}
               -q {set state centralnode}
               -D {incr debugTrace}
               default {error "unknown flag $arg"}
            }
         }
         partname {
            set partname $arg
            set state flag
         }
         mcastaddr {
            set mcastaddr $arg
            set state flag
         }
         portisupc {
            set portisupc $arg
            set state flag
         }
         portisupr {
            set portisupr $arg
            set state flag
         }
         porttoken {
            set porttoken $arg
            set state flag
         }
         mcastiface {
            set mcastiface $arg
            set state flag
         }
	 centralnode {
	    set centralnode $arg
	    set state flag
	 }
      }
   }
   if {$partname == "NOT_SET" || $mcastaddr == "NOT_SET" || $mcastiface == "NOT_SET" || $centralnode == "NOT_SET" ||
       $portisupr == "NOT_SET" || $portisupc == "NOT_SET" || $porttoken == "NOT_SET"} {
      puts "\nERROR: one or more missing command line arguments"
      usage
   }
}

#
#
#-----------------------------------------------------------------------------
proc defineExecutionEnvironment {} {
   global env argv0
   global partname parttype mcastiface
   global mcastaddr portisupc portisupr porttoken centralnode
   global exe_name
   global exe_dir dat_dir cfg_dir
   global mcat_path 
   global nodesListFile netDevConfFile recNodeConfFile switchModeFile messageFile radarFile adsbFile
   global log_dir run_tools_path 
   global DRS REC

   dputs "### defineExecutionEnviornment:"
   
   set  partname           NOT_SET
   set  mcastaddr          NOT_SET
   set  portisupc          NOT_SET
   set  portisupr          NOT_SET
   set  porttoken          NOT_SET
   set  mcastiface         NOT_SET
   set  centralnode        NOT_SET
   #
   # setup program and data directory path info
   #
   set exe_dir         $env(TKSUP_BIN_DIR)
   set dat_dir         $env(TKSUP_DATA_DIR)
   set exe_path        [ split $argv0 "/" ]
   set exe_name        [ lindex $exe_path [ expr { [ llength $exe_path ] - 1 } ] ]

   #
   # special executeables required by tksup
   #
   set  mcat_path          $exe_dir/mcat
   #
   # other variables that can be initialised from environment
   #
   set partname $env(PARTITION)
   parseArgv
   
   regsub {^..} $partname {} parttype
   
   dputs "###      exe_dir = \"$exe_dir\""
   dputs "###      dat_dir = \"$dat_dir\""
   dputs "###      mcat_path = \"$mcat_path\""
   dputs "###      partname = \"$partname\""
   dputs "###      parttype = \"$parttype\""
   
   # offline nodes list file for USER TOOLS list box
   # eg. ALER_nodelist
   #     ALTC_nodelist
   #
   set nodesListFile ${partname}_nodelist
   #
   # offline network devices and IP addresses list for Network monitoring
   # eg. ALER_NetDeviceIP_Address
   #     ALTC_NetDeviceIP_Address
   #
   set netDevConfFile ${partname}_NetDeviceIP_Address 
   #
   # recording node for each partition is offline defined.
   #
   set recNodeConfFile ${partname}_reclist

   # SSS switching config file
   set switchModeFile tksup_switchmodefile

   # message (to find the central node)
   set messageFile message

   # radar names (to convert the RADAR_01_1 to a meaningful name)
   set radarFile ${partname}_radar

   # adsb names (to convert the AFB_LN_1_1 to a meaningful name)
   set adsbFile ${partname}_adsb
   
   set cfg_dir $env(CONF_DIR)
   if { ![ file exists $cfg_dir ] } {
     puts "ERROR: CONF_DIR not defined!"
     exit
   }
   set log_dir $env(LOG_DIR)
   if { ![ file exists $log_dir ] } {
     puts "ERROR: LOG_DIR not defined!"
     exit
   }
   set run_tools_path $env(RUN_TOOLS_DIR)
   if { ![ file exists $run_tools_path ] } {
     puts "ERROR: RUN_TOOLS_DIR not defined!"
     exit
   }
   set REC(AVAILABLE) 0 
   if { ! [ catch { set REC(PATH) $env(REC_DATA_DIR) } ] } {
     if { ! [ file exists $REC(PATH) ] } {
       puts "ERROR: REC_DATA_DIR defined but does not exist!"
       set REC(AVAILABLE) 0
     } else {
       set REC(AVAILABLE) 1
     }
   }

   dputs "###      nodesListFile = \"$nodesListFile\""
   dputs "###      netDevConfFile = \"$netDevConfFile\""
   dputs "###      recNodeConfFile = \"$recNodeConfFile\""
   dputs "###      switchModeFile = \"$switchModeFile\""
   dputs "###      messageFile = \"$messageFile\""
   dputs "###      radarFile = \"$radarFile\""
   dputs "###      adsbFile = \"$adsbFile\""
   dputs "###      log_dir = \"$log_dir\""
   dputs "###      cfg_dir = \"$cfg_dir\""
   dputs "### run_tools_path = \"$run_tools_path\""


  # Only available on a ER or DR partition 
  if { [ string match ??ER $partname ] || [ string match ??DR $partname ] } {
    if { ! [ catch { set res $env(RECOVERY_PARTITION) } ] } {
      if { [ string compare $res "TRUE" ] == 0 } {
        set DRS(PARTITION) 1
      }
    }
  }
}

#-----------------------------------------------------------------------------
proc readOfflineFiles { } {
  global cfg_dir netDevConfFile nodesListFile recNodeConfFile switchModeFile messageFile radarFile adsbFile
  global DATA MODE

  # In general : lines starting with "#" and blank lines ignored

  # netDevConfFile
  # list of network devices to monitor
  # <IP> <name>
  set DATA(NETWORK) {}
  if { [ file exists $cfg_dir/$netDevConfFile ] } {
    set fileId [ open $cfg_dir/$netDevConfFile r ]
    while { [ gets $fileId data ] >= 0 } {
      # Remove comment lines
      if { [ string compare [ string index $data 0 ] "#" ] != 0 } {
        # Remove empty lines
        if { [ string compare $data "" ] != 0 } {
          # Save the data
            lappend DATA(NETWORK) [ string trim $data ]
        }
      }
    }
    close $fileId
    if { $DATA(NETWORK) == {} } {
      dputs "The file <$cfg_dir/$netDevConfFile> is empty"
    }
  } else {
    dputs "The file <$cfg_dir/$netDevConfFile> does not exist"
  }


  # nodesListFile
  # list of all nodes in the partition
  # <node>
  set DATA(NODES) {}
  if { [ file exists $cfg_dir/$nodesListFile ] } {
    set fileId [ open $cfg_dir/$nodesListFile r ]
    while { [ gets $fileId data ] >= 0 } {
      # Remove comment lines
      if { [ string compare [ string index $data 0 ] "#" ] != 0 } {
        # Remove empty lines
        if { [ string compare $data "" ] != 0 } {
          # Save the data
          if { [ lsearch -exact $DATA(NODES) $data ] == -1 } {
            lappend DATA(NODES) $data
          } else {
            dputs "Duplicate node name $data in file $nodesListFile (ignored)"
          }
        }
      }
    }
    close $fileId
    if { $DATA(NODES) == {} } {
      dputs "The file <$cfg_dir/$nodesListFile> is empty"
    }
  } else {
    dputs "The file <$cfg_dir/$nodesListFile> does not exist"
  }

  # recNodeConfFile
  # list of REC nodes
  # <node>
  set DATA(REC) {}
  if { [ file exists $cfg_dir/$recNodeConfFile ] } {
    set fileId [ open $cfg_dir/$recNodeConfFile r ]
    while { [ gets $fileId data ] >= 0 } {
      # Remove comment lines
      if { [ string compare [ string index $data 0 ] "#" ] != 0 } {
        # Remove empty lines
        if { [ string compare $data "" ] != 0 } {
          # Save the data
          if { [ lsearch -exact $DATA(REC) $data ] == -1 } {
            lappend DATA(REC) $data
          } else {
            dputs "Duplicate node name $data in file $recNodeConfFile (ignored)"
          }
        }    
      }
    }
    close $fileId
    if { $DATA(REC) == {} } { 
      dputs "The file <$cfg_dir/$recNodeConfFile> is empty"
    } 
  } else {
    dputs "The file <$cfg_dir/$recNodeConfFile> does not exist"
  }

  # SSS switchModeFile 
  # <mode> <version> : <nodelist> <setver_script> [ <nodelist> <setver_script> ]
  # mode is either SIMU or OPER
  # eg:
  # SIMU 11.1626.0 : cttr_he_multi cttr_he_sim_ol
  # OPER 11.1626.0 : cter cter_dbm cter_byp
  set DATA(MODE) {}
  set MODE(AVAILABLE) 1
  if { [ file exists $cfg_dir/$switchModeFile ] } {
    set fileId [ open $cfg_dir/$switchModeFile r ]
    while { [ gets $fileId data ] >= 0 } {
      # Remove comment lines
      if { [ string compare [ string index $data 0 ] "#" ] != 0 } {
        # Remove empty lines
        if { [ string compare $data "" ] != 0 } {
          # Save the data
          lappend DATA(MODE) $data
        }
      }
    }
    close $fileId
    if { $DATA(MODE) == {} } {
      dputs "The file <$cfg_dir/$switchModeFile> is empty"
      set MODE(AVAILABLE) 0
    }
  } else {
    dputs "The file <$cfg_dir/$switchModeFile> does not exist"
    set MODE(AVAILABLE) 0
  }


  # message file
  # <csci> <nodeA> [ <nodeB> ]
  # CENTRAL <nodeA> [ <nodeB> ]
  # TRADE_REF <nodeA>
  set DATA(MESSAGE) {}
  if { [ file exists $cfg_dir/$messageFile ] } {
    set fileId [ open $cfg_dir/$messageFile r ]
    while { [ gets $fileId data ] >= 0 } {
      # Remove comment lines
      if { [ string compare [ string index $data 0 ] "#" ] != 0 } {
        # Remove empty lines
        if { [ string compare $data "" ] != 0 } {
          # Save the data
          lappend DATA(MESSAGE) $data
        }
      }
    }
    close $fileId
    if { $DATA(MESSAGE) == {} } {
      dputs "The file <$cfg_dir/$messageFile> is empty"
    }
  } else {
    dputs "The file <$cfg_dir/$messageFile> does not exist"
  }

  # radar name file
  # One radar name per line, no spaces
  # "*" treated as a blank by the code
  set DATA(RADAR) {}
  if { [ file exists $cfg_dir/$radarFile ] } {
    set fileId [ open $cfg_dir/$radarFile r ]
    while { [ gets $fileId data ] >= 0 } {
      # Remove comment lines
      if { [ string compare [ string index $data 0 ] "#" ] != 0 } {
        # Remove empty lines
        if { [ string compare $data "" ] != 0 } {
          # Save the data
          lappend DATA(RADAR) $data
        }
      }
    }
    close $fileId
    if { $DATA(RADAR) == {} } {
      dputs "The file <$cfg_dir/$radarFile> is empty"
    }
  } else {
    dputs "The file <$cfg_dir/$radarFile> does not exist"
  }

  # adsb name file
  # One adsb name per line, no spaces
  # "*" treated as a blank by the code
  set DATA(AFB) {}
  if { [ file exists $cfg_dir/$adsbFile ] } {
    set fileId [ open $cfg_dir/$adsbFile r ]
    while { [ gets $fileId data ] >= 0 } {
      # Remove comment lines
      if { [ string compare [ string index $data 0 ] "#" ] != 0 } {
        # Remove empty lines
        if { [ string compare $data "" ] != 0 } {
          # Save the data
          lappend DATA(AFB) $data
        }
      }
    }
    close $fileId
    if { $DATA(AFB) == {} } {
      dputs "The file <$cfg_dir/$adsbFile> is empty"
    }
  } else {
    dputs "The file <$cfg_dir/$adsbFile> does not exist"
  }
}

#--------------------------------------------------------------------------
proc LOG_write { txt { severity ? } } {
  global color time_str i
  global LOG ALARM

  # I : Information
  # W : Warning
  # F : Fatal

  if { [ string first $severity "IWF" ] == -1 } {
    puts "LOG_write : Invalid severity!"
    set severity F
  }

  if { $LOG($severity,ONLINE) == 1 } {
    $LOG(TEXT) configure -state normal
    $LOG(TEXT) insert end "$time_str <<${severity}>> $txt\n" $color($severity)
    $LOG(TEXT) see end
    $LOG(TEXT) configure -state disabled
  }

  if { $LOG($severity,PRINT) == 1 } {
    Print "$time_str <<${severity}>> $txt"
  }

  if { $LOG($severity,LOG) == 1 } {
    if { $LOG(STREAM) != -1 } {
      puts $LOG(STREAM) "[pid] $time_str <<${severity}>> $txt"
      flush $LOG(STREAM)
    }
  }

  if { [ string first $severity "F" ] != -1 } {
    set ALARM(COUNT) 4 
  }
}

#-----------------------------------------------------------------------------

proc ALARM_ring { } {
  global ALARM

  dputs "## ALARM_ring : on($ALARM(ON)) count($ALARM(COUNT))"

  set delay 3000

  if { $ALARM(ON) } {
    if { $ALARM(COUNT) >= 0 } {
      incr ALARM(COUNT) -1
      bell
      set delay 200
    }
  }

  after $delay ALARM_ring
}

#--------------------------------------------------------------------------------
proc Print { message } {
  global PRINT rcmd

  dputs "### Print: (($PRINT(VALIDNODE))($PRINT(CUPS)) --> ($message)"

  if { $PRINT(VALIDNODE) } {
    set cmd "$rcmd $PRINT(NODE) \"echo  \\\"$message\\\" > /dev/ttyS0 &\""
    dputs "### printCmd($cmd)"
  } elseif { $PRINT(CUPS) } {
    set cmd "echo ${message}\\r | lpr -P $PRINT(CUPS_NAME) -o raw &"
    dputs "### printCmd($cmd)"
  }
  set res [ exec_command $cmd ]
  if { [ lindex $res 0 ] != 0 } {
    dputs "Error in Print : [ lindex $res 1 ]"
  }
}

#--------------------------------------------------------------------------------

proc PRINT_validateNode { } {
  global font12 font14 
  global PRINT rcmd

  dputs "### PRINT_validateNode"

  $PRINT(MSG) configure -text ""
  set PRINT(VALIDNODE) 0

  if { $PRINT(CUPS) == 1 } {
    if { [ string length $PRINT(CUPS_NAME) ] <= 0 } {
      $PRINT(MSG) configure -text "Error: Missing CUPS service name" -fg darkred -font $font14
      set PRINT(CUPS) 0
      return
    } else {
      $PRINT(MSG) configure -text "CUPS enabled" -fg green -font $font14
    }
  } elseif { [ string length $PRINT(NODE) ] > 0 } {
    # See if we can reach the node firstly!
    set ping_res [ ping_node $PRINT(NODE) ]
    if { $ping_res == 0 } {

      # Linux boxes and the Unix boxes have different device setups...
      set checkPrinterRshCmd "$rcmd $PRINT(NODE) \"ls -la /dev/ttyS0\""

      # Okay, we can ping the node - see if the serial port is setup 
      # and available to access (ie not just root access)
      set cmd_result [ exec_command $checkPrinterRshCmd ]

      # check that there is serial device setup
      # example string:
      # "ls: /dev/ttyS0: No such file or directory"
      if { [ string first "No such file or directory" [ lindex $cmd_result 1 ] ] == -1 } {
        # check permissions on the device
        # example string:
        # "crw-rw-rw-    1 root     root       5,   0 Jan 14 03:41 /dev/ttyS0"
        if { [ string match "?rw?rw?rw?" [ string range [ lindex $cmd_result 1 ] 0 9 ] ] } {
          set PRINT(VALIDNODE) 1
          $PRINT(MSG) configure -text "Printer attached to $PRINT(NODE)" -fg green -font $font14
          return
        } else {
          $PRINT(MSG) configure -text "Error: incorrect permissions set on /dev/tty??" -fg darkred -font $font14
          return
        }
      } else {
        $PRINT(MSG) configure -text "Error: missing /dev/tty?? on $PRINT(NODE)" -fg darkred -font $font14
        return
      }
    } else {
      $PRINT(MSG) configure -text "Error: $PRINT(NODE) not reachable" -fg darkred -font $font14
      return
    }
  } else {
    $PRINT(MSG) configure -text "Error: Missing node name" -fg darkred -font $font14
    return
  }
}
                                                               
#--------------------------------------------------------------------------------

proc PRINT_setup { } {

  global PRINT font12 font14 

  dputs "### PRINT_setup:"

  if { [ string length [ info command .prnSetup ] ] == 0 } { 
    toplevel .prnSetup -bg darkgrey
    wm geometry .prnSetup +0+0
    wm title .prnSetup "PRINTER SETUP"
    wm resizable .prnSetup 0 0

    frame .prnSetup.f1 -borderwidth 5 -relief ridge -bg blue
    pack .prnSetup.f1 -side top -fill x -expand 1
    frame .prnSetup.f1.f2 -bd 2 -relief raised -bg grey90
    pack .prnSetup.f1.f2 -side top -fill both -expand 1 -ipadx 20

    set p .prnSetup.f1.f2

    frame $p.f1 -bg grey90
    checkbutton $p.f1.cb -text "Use CUPS" -variable PRINT(CUPS)
    label $p.f1.l1 -text "CUPS Name" -padx 0 -bg grey -font $font14
    entry $p.f1.cupsName -width 15 -relief sunken -bg white -textvariable PRINT(CUPS_NAME) -fg black -font $font14
    pack $p.f1.cb -side left
    pack $p.f1.l1 -side left
    pack $p.f1.cupsName -side left -fill x -expand true

    # create machine name text entry area. Machine name provided 
    # will be used to print 
    frame $p.f3 -bg grey90
    label $p.f3.lab1 -text "Enter printer node " -padx 0 -bg grey -font $font14   
    entry $p.f3.prnNodeName -width 15 -relief sunken -bg white -textvariable PRINT(NODE) -fg black -font $font14
    pack $p.f3.lab1 -side left
    pack $p.f3.prnNodeName -side left -fill x -expand true

    frame $p.f4 -bg grey90
    label $p.f4.lab2 -padx 0 -bg grey -font $font14
    pack $p.f4.lab2 -side top -fill x 
    set PRINT(MSG) $p.f4.lab2


    # build the window
    pack $p.f3 -side top -fill x -padx 5 -pady 3
    pack $p.f1 -side top -fill x -padx 5 -pady 3
    pack $p.f4 -side top -fill x -padx 5 -pady 3
	
    bind $p.f3.prnNodeName <KeyPress-Return> PRINT_validateNode
    button .prnSetup.but1 -text "Attach" -width 6 -command PRINT_validateNode \
                       -bg darkgrey -font $font12
    button .prnSetup.but2 -text "Close" -width 6 -font $font12 \
                     -command { destroy .prnSetup } -bg darkgrey

    pack .prnSetup.but1 -side left -padx 5 -pady 3 
    pack .prnSetup.but2 -side right -padx 5 -pady 3
  } else {
    bell -displayof .
    raise .prnSetup
  }
}

###################################################################
 
proc SWITCH_setup { } {
  global font12 font14 dat_dir count partname
  global SW_DATA DATA

  dputs "### switchIPSetup:"

  if { $SW_DATA(DISPLAY) == -1 } {

    if { [ llength $DATA(NETWORK) ] == 0 } {
      display_message "No network devices have been defined" red
      return 
    }

    set SW_DATA(DISPLAY) .switchIPSetup
    toplevel $SW_DATA(DISPLAY) -bg darkgrey 
    wm geometry $SW_DATA(DISPLAY) +0+0
    wm title $SW_DATA(DISPLAY) "$partname / Network Devices" 
    wm resizable $SW_DATA(DISPLAY)  0 0
    wm protocol $SW_DATA(DISPLAY) WM_DELETE_WINDOW SWITCH_close 
  
    frame $SW_DATA(DISPLAY).frm1 -borderwidth 5 -relief ridge -bg green
    pack  $SW_DATA(DISPLAY).frm1 -side top -fill x

    frame $SW_DATA(DISPLAY).frm1.frm2 -borderwidth 5 -relief flat -bg grey
    pack  $SW_DATA(DISPLAY).frm1.frm2 -side left -fill both 

    frame $SW_DATA(DISPLAY).frm1.frm3 -borderwidth 5 -relief flat -bg grey 
    pack  $SW_DATA(DISPLAY).frm1.frm3 -side right -fill both 

    set netDevIP {}
    set netDevName {}
    foreach network_dev $DATA(NETWORK) {
      if { [ lsearch -exact $netDevIP [ lindex $network_dev 0 ] ] != -1 } {
        puts "Duplicate IP entry ([ lindex $network_dev 0 ]) found - discarding duplicate entry" 
      } else {
        if { [ lsearch -exact $netDevName [ lindex $network_dev 1 ] ]  != -1 } {
          puts "Duplicate NAME entry ([ lindex $network_dev 1 ]) found - discarding duplicate entry" 
        } else {
          lappend netDevIP [ lindex $network_dev 0 ] 
          lappend netDevName [ lindex $network_dev 1 ]
        }
      }
    }  

    set SW_DATA(NUMBER_OF_SWITCH) [ llength $netDevIP ]
    if { $SW_DATA(NUMBER_OF_SWITCH) != 0 } {
      set col 0
      set row 0
      set col_max [ expr $SW_DATA(NUMBER_OF_SWITCH) / 8 ]
      foreach devIP $netDevIP {
        set devIndex [ lsearch -exact $netDevIP $devIP ]
        set devName [ lindex $netDevName $devIndex ]

        set SW_DATA($devIndex,IP) $devIP
        set SW_DATA($devIndex,NAME) $devName
        set SW_DATA($devIndex,ID) $devIndex
        set SW_DATA($devIndex,WINDOW) ""
        set SW_DATA($devIndex,EVENT) -1
        set SW_DATA($devIndex,INDEX) {}
        set SW_DATA($devIndex,PORTS) 0
        set SW_DATA($devIndex,PORT_MAX) -1
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        set SW_DATA($devIndex,STATE) INIT
        set SW_DATA($devIndex,COUNTER) 0
      
        button $SW_DATA(DISPLAY).frm1.frm2.b$devIndex -text "$devName\n($devIP)"  -borderwidth 3 -width 25 -bg slategrey -fg yellow
        bind $SW_DATA(DISPLAY).frm1.frm2.b$devIndex <Enter> { %W config -activebackground yellow -activeforeground blue }
        bind  $SW_DATA(DISPLAY).frm1.frm2.b$devIndex <Leave> { %W config -bg slategrey }
        bind  $SW_DATA(DISPLAY).frm1.frm2.b$devIndex <ButtonRelease-1> [ list SWITCH_manageSwitch $devIndex ]
        grid  $SW_DATA(DISPLAY).frm1.frm2.b$devIndex -pady 3 -padx 3 -row $row -column $col
        incr col 1
        if { $col >= $col_max } {
          set col 0
          incr row 1
        }
      }
      button $SW_DATA(DISPLAY).close -text "Close" -width 6 -font $font12 -command SWITCH_close \
                                  -fg red -bg darkgrey -activebackground lemonchiffon1 
      pack $SW_DATA(DISPLAY).close -side top 
    }
  } else {
    bell -displayof .
    raise $SW_DATA(DISPLAY)
  }
}                 

###################################################################
proc SWITCH_resetData { devIndex devName devIP } {
  global SW_DATA

  array unset SW_DATA "$devIndex,*"

  set SW_DATA($devIndex,IP) $devIP
  set SW_DATA($devIndex,NAME) $devName
  set SW_DATA($devIndex,ID) $devIndex
  set SW_DATA($devIndex,WINDOW) ""
  set SW_DATA($devIndex,EVENT) -1
  set SW_DATA($devIndex,INDEX) {}
  set SW_DATA($devIndex,PORTS) 0
  set SW_DATA($devIndex,PORT_MAX) -1
  set SW_DATA($devIndex,STREAM) -1
  set SW_DATA($devIndex,STREAM_PID) -1
  set SW_DATA($devIndex,STATE) INIT
  set SW_DATA($devIndex,COUNTER) 0

}

###################################################################

proc Scroll_Set {scrollbar geoCmd offset size} {

  dputs "### Scroll_Set: $scrollbar  $geoCmd  $offset  $size"
  if {$offset != 0.0 || $size !=0} {
    eval $geoCmd
  }
  $scrollbar set $offset $size
}

####################################################################
proc Scrolled_Listbox { f args } {

  dputs "### Scrolled_Listbox: $f $args"

  frame $f -bg grey 
  listbox $f.list -fg black -yscrollcommand [ list Scroll_Set $f.yscroll \
                     [ list grid $f.yscroll -row 0 -column 1 -sticky ns ] ]
  eval { $f.list configure } $args
  scrollbar $f.yscroll -orient vertical -bg darkgrey -command [ list $f.list yview ]

  grid $f.list -sticky news
  grid rowconfigure  $f 0 -weight 1
  grid columnconfigure $f 0 -weight 1

  return $f.list
}

#---------------------------------------------------------------------
proc checkTokenAndCallissuecmd { win } {
  global TOKEN

  dputs "### checkTokenAndCallissuecmd: $win"

  set buff [ split $win "." ]                           ; # eliminate "."
  set tempList [ lindex $buff end ]                     ; # get the last item in the list
  regsub ^b  $tempList {} userCmdName                   ; # eliminate "b"

  dputs "###     userCmdName: $userCmdName"

  set doUserCmd 0
  if { [ string compare $TOKEN(STATE) "LOCAL" ] == 0 } {
    switch -exact -- $userCmdName {
      start   { issuecmd START }
      stop    { issuecmd STOP  }
      dataset { issuecmd DATASET }
      system  { systemMon }
      loadsys { issuecmd LOADSYS }
      switch  { issuecmd SWITCHDNC }
    }
  } else {
    display_message "TKSUP does not have access control to the system to perform $userCmdName. \
                     To be able to perform the action, click \"Get Token\" button to request TOKEN for access control." blue
  }
} 

#----------------------------------------------------------------------
proc List_Select { parent values } {
  global picked choices unselected_nodes selected_nodes 
  global font12 font14 font14 start_cold_var
 
  dputs "### List_Select: $parent  $values"
     
  set unselected_nodes $values 
  set selected_nodes {}

  frame $parent -bg grey
 
  # frame for lists and labels
  frame $parent.topl -bg grey
  set choices [ Scrolled_Listbox $parent.topl.choices -font $font14 -width 15 -height 15 -bg grey -fg black -listvariable unselected_nodes ]
  set picked [ Scrolled_Listbox $parent.topl.picked -font $font14  -width 15 -height 15 -bg grey -fg red -listvariable selected_nodes ]

  label $parent.topl.l1 -text "Available Nodes" -bg grey  -font $font14 -fg black 
  label $parent.topl.l2 -text "Selected Nodes" -anchor s -bg grey -font $font14 -fg black -bd 3
  grid $parent.topl.l1 -row 0 -column 0 -sticky w
  grid $parent.topl.l2 -row 0 -column 1 -sticky w
  grid $parent.topl.choices -row 1 -column 0
  grid $parent.topl.picked -row 1 -column 1
  grid columnconfigure $parent.topl 0 -weight 1
  grid columnconfigure $parent.topl 1 -weight 1
  grid rowconfigure  $parent.topl 1 -weight 1

  # frame to hold control buttons
  frame $parent.botl -bg grey
  button $parent.botl.bsel -text "Select All " -width 12 -command { SelectAll } \
                           -bg darkgrey -font $font14 -fg black -bd 3
  button $parent.botl.bdesel -text "DeSelect All " -width 12 -command { DeSelectAll } \
                             -bg darkgrey -font $font14 -fg black -bd 3
  pack $parent.botl.bsel -side left -padx 10
  pack $parent.botl.bdesel -side right -padx 10
 
  # frame to hold the cancel button
  frame $parent.botr -bg grey
  button $parent.botr.bcancel -text "Cancel " -width 10 -font $font14 \
                              -command {handle_usrwin .cmd_window "cmd_window_inuse"} \
                              -bg darkgrey -fg black -bd 3
  pack $parent.botr.bcancel  -side right

  # frame to hold tool buttons and check button
  frame $parent.topr -bg grey
  pack $parent.topr -side right -fill both -pady 5 

  checkbutton $parent.topr.cb -text " cold " -variable start_cold_var -relief ridge
  button $parent.topr.bstart -text "Start Node " -width 10 -bg green -font $font14 -fg black -bd 3 
  bind  $parent.topr.bstart <ButtonRelease-1> { checkTokenAndCallissuecmd  %W  }

  button $parent.topr.bdataset -text "DATASET" -width 10 -bg darkgrey -font $font14  -fg black -bd 3 
  bind  $parent.topr.bdataset <ButtonRelease-1> { checkTokenAndCallissuecmd  %W  }

  button $parent.topr.bsystem -text "System" -width 10 -bg darkgrey -font $font14  -fg black -bd 3
  bind $parent.topr.bsystem <ButtonRelease-1> { checkTokenAndCallissuecmd  %W  }

  button $parent.topr.bloadsys -text "Load System" -width 10 -bg yellow -font $font14  -fg black -bd 3
  bind $parent.topr.bloadsys <ButtonRelease-1> { checkTokenAndCallissuecmd  %W  }

  button $parent.topr.bswitch -text "Switch Node" -width 10 -bg darkgrey -font $font14  -fg black -bd 3
  bind $parent.topr.bswitch <ButtonRelease-1> { checkTokenAndCallissuecmd  %W  }

  button $parent.topr.bstop -text "Stop Node " -width 10 -bg red -font $font14  -fg black -bd 3
  bind  $parent.topr.bstop <ButtonRelease-1> { checkTokenAndCallissuecmd  %W  }

  grid $parent.topr.bstart $parent.topr.cb  -pady 3 -padx 3 -sticky w
  foreach bitem { dataset system loadsys switch stop } { 
    grid $parent.topr.b$bitem -pady 3 -padx 3 -sticky w
  }

  grid $parent.topl -row 0 -column 0 -padx 3 -pady 3
  grid $parent.topr -row 0 -column 1 -padx 3 -pady 3
  grid $parent.botl -row 1 -column 0 -padx 3 -pady 3
  grid $parent.botr -row 1 -column 1 -padx 3 -pady 3
  grid rowconfigure $parent 0 -weight 1
  grid columnconfigure $parent 0 -weight 1
  grid columnconfigure $parent 1 -weight 1

  # selecting in choices moves items into picked and deletes that item from choices
  bind $choices <ButtonRelease-1> [ list ListTransferSel %W $picked %y ]
  # selecting in picked moves items into choices ane deletes that item from picked
  bind $picked <ButtonRelease-1> [ list ListTransferSel %W $choices %y ]

}

#-------------------------------------------------------------------------------------------------
proc exec_command { command } {

  set check_a [ catch { eval exec $command } check_b ]

  if { $check_a != 0 } {
    dputs "Error: Problem running ${command}. Program returns : ${check_b}"
  }
  return [ list $check_a $check_b ]

}


#-------------------------------------------------------------------------------------------------
proc runRecTool { } {
  global run_tools_path display suffix time_str
  global exe_dir REC rcmd

  dputs "### runRecTool:"
  LOG_write "Opening rec_tools on localhost" I

  set recToolsCmd "${REC(PATH)}/rec_tools"
  set res [ exec_command $recToolsCmd ]

  if { [ lindex $res 0 ] != 0 } {
    display_message "Error: [ lindex $res 1 ]" red
    LOG_write "Error opening rec_tools" W
  }
} 

#-----------------------------------------------------------------------------------
proc scrollbar_fixup { w width height } {
  if { [ string compare [ $w cget -scrollregion ] [ list 0 0 $width $height ] ] != 0 } {
    $w configure -scrollregion [ list 0 0 $width $height ]
    $w configure -width $width
  }
}

#----------------------------------------------------------------------
proc SYSMON_close { } {
  global SYSMON

  destroy $SYSMON(DISPLAY)
  if { $SYSMON(STREAM_PID) != -1 } {
    exec_command "kill -s SIGINT $SYSMON(STREAM_PID)"
  }
  unset SYSMON
  set SYSMON(DISPLAY) -1
  set SYSMON(STREAM) -1
  set SYSMON(STREAM_PID) -1
}

#----------------------------------------------------------------------
proc SYSMON_refresh { } {
  global SYSMON

  if { $SYSMON(STREAM) != -1 } {
    dputs "Refresh already in progress!"
    # Refresh already in process
    return
  }
  if { $SYSMON(STREAM_PID) != -1 } {
    # Refresh already in progress
    dputs "Refresh already in progress"
    return
  }

  set SYSMON(NODES,TODO) $SYSMON(NODES)
  set SYSMON(NODES,DONE) {}
  set SYSMON(NODES,INPROGRESS) {} 

  SYSMON_getData

}

#----------------------------------------------------------------------
proc SYSMON_parseData { river } {
  global SYSMON

  dputs "### SYSMON_parseData river($river)"

  if { [ eof $river ] } {
#    puts "EOF!"
    close $river
    set SYSMON(STREAM) -1
    set SYSMON(STREAM_PID) -1
    # EOF means the end of one rsh stream. Display the info gathered then relaunch the proc to get more data.
    SYSMON_buildData
    SYSMON_getData
  } else {
#    puts "not EOF!"
    if { [ gets $river line ] < 0 } {
      return
    } else {
      dputs "### SYSMON_parseData line($line)"
      
#      if { $SYSMON(STREAM) == -1 } {
#        return
#      }
      # we have data! parse it and update the display
      # Using /usr/bin/sar, so ignore lines except those starting with "Average:" or "Linux"
      set cleanLine [ stripBlank [ split $line ] ]
      set lineID [ llength $cleanLine ]
      dputs "($lineID)($cleanLine)"
      switch -- $lineID {
        0 { return }
        5 {
            if { [ string match {*: No route to host} $cleanLine ] } {
              set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),RESPOND) 0
            }
          }
        6 {
            if { [ string equal [ lindex $cleanLine 0 ] "Average:" ] } {
              if { ! [ string equal [ lindex $cleanLine 1 ] "kbswpfree" ] } {
                # Swap -> Average:    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad
                set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),SWAP,FREE) [ lindex $cleanLine 1 ]
                set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),SWAP,USED) [ lindex $cleanLine 2 ]
                set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),SWAP,TOTAL) [ expr [ lindex $cleanLine 1 ] + [ lindex $cleanLine 2 ] ]
              }
            } elseif { ! [ string match {[0-9][0-9]:[0-9][0-9]:[0-9][0-9]} [ lindex $cleanLine 0 ] ] } {
              set cnt $SYSMON(DATA,$SYSMON(NODES,INPROGRESS),FILE)
              for { set x 0 } { $x < 6 } { incr x } {
                set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),FILE,$cnt,$x) [ lindex $cleanLine $x ]
              }
              incr SYSMON(DATA,$SYSMON(NODES,INPROGRESS),FILE)
            }
          }
        7 {
            if { [ string equal [ lindex $cleanLine 0 ] "Linux" ] } {
              # Linux 2.6.32-431.23.3.el6.i686 (ctercms01li)    07/05/2016      _i686_  (4 CPU)
              set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),LINUX) [ lindex $cleanLine 1 ]
            } elseif { [ string equal [ lindex $cleanLine 0 ] "Filesystem" ] } {
              for { set x 0 } { $x < 6 } { incr x } {
                set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),FILE,0,$x) [ lindex $cleanLine $x ]
              }
              set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),FILE) 1
            }
          }
        8 {
            if { [ string equal [ lindex $cleanLine 0 ] "Average:" ] } {
              if { [ string equal [ lindex $cleanLine 1 ] "all" ] } {
                #   CPU -> Average:        CPU     %user     %nice   %system   %iowait    %steal     %idle
                set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),CPU,USER) [ lindex $cleanLine 2 ]
                set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),CPU,SYSTEM) [ lindex $cleanLine 4 ]
                set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),CPU,IDLE) [ lindex $cleanLine 7 ]
              }
            }
          }
        11 {
             if { [ string equal [ lindex $cleanLine 0 ] "Average:" ] } {
               if { ! [ string equal [ lindex $cleanLine 1 ] "kbmemfree" ] } {
                 # Average:    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
                 # Average:       418176   7679552     94.84    209172   3826112   5264304     31.93   4645700   2473960       824
                 set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),MEM,FREE) [ lindex $cleanLine 1 ]
                 set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),MEM,USED) [ lindex $cleanLine 2 ]
                 set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),MEM,TOTAL) [ expr [ lindex $cleanLine 1 ] + [ lindex $cleanLine 2 ] ]
               }
             }
           }
        default {
          dputs "Data in unknown format : ($lineID)($cleanLine)"
        }
      }
    }
  }
}

#----------------------------------------------------------------------
proc SYSMON_buildData { } {
  global SYSMON font18 

  if { $SYSMON(DISPLAY) == -1 } {
    return
  }

  if { [ string length [ info command $SYSMON(CANVAS).f$SYSMON(NODES,INPROGRESS) ] ] == 0 } {

    set node $SYSMON(NODES,INPROGRESS)
    set tmpf $SYSMON(CANVAS).f$node

    frame $tmpf -bg darkgrey -relief sunken -bd 5

    if { $SYSMON(DATA,$node,RESPOND) == 0 } {
      label $tmpf.l1 -bg grey -fg red -text "Node $node is not responding" -font $font18
      grid $tmpf.l1 -row 0 -column 0 -sticky we

    } else {
      grid columnconfigure $tmpf 1 -weight 1

      label $tmpf.l1 -bg grey -text $node -font $font18
      grid $tmpf.l1 -row 0 -column 0 -sticky we -columnspan 5
  
      label $tmpf.l2 -bg grey -text "OS"
      frame $tmpf.fOS -bg darkgrey
      label $tmpf.fOS.l1 -bg darkgrey -text "Linux ( version"
      label $tmpf.fOS.l2 -bg darkgrey -textvariable SYSMON(DATA,$node,LINUX)
      label $tmpf.fOS.l3 -bg darkgrey -text ")"
      grid $tmpf.l2 -row 1 -column 0 -sticky new
      pack $tmpf.fOS.l1 $tmpf.fOS.l2 $tmpf.fOS.l3 -side left
      grid $tmpf.fOS -row 1 -column 1 -sticky nw -padx 10 -pady 4
      
      label $tmpf.l3 -bg grey -text "CPU"
      frame $tmpf.fCPU -bg darkgrey
      label $tmpf.fCPU.l1 -bg darkgrey -text "User:" 
      label $tmpf.fCPU.l2 -bg darkgrey -textvariable SYSMON(DATA,$node,CPU,USER)
      label $tmpf.fCPU.l3 -bg darkgrey -text "%  System:"
      label $tmpf.fCPU.l4 -bg darkgrey -textvariable SYSMON(DATA,$node,CPU,SYSTEM)
      label $tmpf.fCPU.l5 -bg darkgrey -text "%  Idle:"
      label $tmpf.fCPU.l6 -bg darkgrey -textvariable SYSMON(DATA,$node,CPU,IDLE)
      label $tmpf.fCPU.l7 -bg darkgrey -text "% "
      grid $tmpf.l3 -row 2 -column 0 -sticky nwe
      pack $tmpf.fCPU.l1 $tmpf.fCPU.l2 $tmpf.fCPU.l3 $tmpf.fCPU.l4 $tmpf.fCPU.l5 $tmpf.fCPU.l6 $tmpf.fCPU.l7 -side left
      grid $tmpf.fCPU -row 2 -column 1 -sticky nw -padx 10 -pady 4
  
      label $tmpf.l4 -bg grey -text "MEM"
      frame $tmpf.fMEM -bg darkgrey
      label $tmpf.fMEM.l1 -bg darkgrey -text "Total :"
      label $tmpf.fMEM.l2 -bg darkgrey -textvariable SYSMON(DATA,$node,MEM,TOTAL)
      label $tmpf.fMEM.l3 -bg darkgrey -text "kb (Free :"
      label $tmpf.fMEM.l4 -bg darkgrey -textvariable SYSMON(DATA,$node,MEM,FREE)
      label $tmpf.fMEM.l5 -bg darkgrey -text "kb)"
      frame $tmpf.fSWAP -bg darkgrey
      label $tmpf.fSWAP.l1 -bg darkgrey -text "Total :"
      label $tmpf.fSWAP.l2 -bg darkgrey -textvariable SYSMON(DATA,$node,SWAP,TOTAL)
      label $tmpf.fSWAP.l3 -bg darkgrey -text "kb (Free :"
      label $tmpf.fSWAP.l4 -bg darkgrey -textvariable SYSMON(DATA,$node,SWAP,FREE)
      label $tmpf.fSWAP.l5 -bg darkgrey -text "kb)"
      grid $tmpf.l4 -row 3 -column 0 -sticky new
      pack $tmpf.fMEM.l1 $tmpf.fMEM.l2 $tmpf.fMEM.l3 $tmpf.fMEM.l4 $tmpf.fMEM.l5 -side left
      pack $tmpf.fSWAP.l1 $tmpf.fSWAP.l2 $tmpf.fSWAP.l3 $tmpf.fSWAP.l4 $tmpf.fSWAP.l5 -side left
      grid $tmpf.fMEM -row 3 -column 1 -sticky nw -padx 10 -pady 4
      grid $tmpf.fSWAP -row 4 -column 1 -sticky nw -padx 10 -pady 4
  
      frame $tmpf.fFILE -bg darkgrey
      for { set x 0 } { $x < $SYSMON(DATA,$node,FILE) } { incr x } {
        for { set y 0 } { $y < 6 } { incr y } {
          if { $x == 0 } {
            label $tmpf.fFILE.h$y -bg grey -text $SYSMON(DATA,$node,FILE,$x,$y)
            grid $tmpf.fFILE.h$y -row $x -column $y -padx 2 -pady 2 -sticky we
          } else {
            label $tmpf.fFILE.d${x}_${y} -bg darkgrey -textvariable SYSMON(DATA,$node,FILE,$x,$y) 
            grid $tmpf.fFILE.d${x}_${y} -row $x -column $y -padx 2 -pady 2 -sticky we
          }
        }
      }
      grid $tmpf.fFILE -row 5 -column 0 -columnspan 3 -sticky w

    } 
    pack $tmpf -side top -fill x -expand 1
  }
}

#----------------------------------------------------------------------
proc SYSMON_getData { } {
  global SYSMON suffix rcmd

  if { $SYSMON(STREAM) != -1 } {
    return
  }

  if { $SYSMON(DISPLAY) == -1 } {
    return
  }

  if { [ llength $SYSMON(NODES,TODO) ] > 0 } {

    set SYSMON(NODES,INPROGRESS) [ lindex $SYSMON(NODES,TODO) 0 ]
    lappend SYSMON(NODES,DONE) $SYSMON(NODES,INPROGRESS)
    set SYSMON(NODES,TODO) [ lreplace $SYSMON(NODES,TODO) 0 0 ]
    set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),FILE) 0
    set SYSMON(DATA,$SYSMON(NODES,INPROGRESS),RESPOND) 1

    set SYSMON(STREAM) [open "|$rcmd $SYSMON(NODES,INPROGRESS)$suffix \"/usr/bin/sar -u -r -S 1 1 ; /bin/df -hP\" 2>@1" r ]
    set SYSMON(STREAM_PID) [ pid $SYSMON(STREAM) ]
    fconfigure $SYSMON(STREAM) -blocking 0
    fileevent $SYSMON(STREAM) readable [ list SYSMON_parseData $SYSMON(STREAM) ]

  }
}

#----------------------------------------------------------------------
proc systemMon { } {
  global selected_nodes font12 font14 font18
  global SYSMON

  dputs "### systemMon:"

  if { [ llength $selected_nodes ] == 0 } {
    display_message "Please select a node to perform system monitor !" blue
    LOG_write "Please select a node" I
  } else {
    if { $SYSMON(DISPLAY) == -1 } {
      set SYSMON(DISPLAY) .sysInf
      toplevel $SYSMON(DISPLAY) -bg darkgrey
      wm geometry $SYSMON(DISPLAY) +50+50
      wm title $SYSMON(DISPLAY) "SYSTEM INFORMATION"
      wm resizable $SYSMON(DISPLAY) 0 1
      wm protocol $SYSMON(DISPLAY) WM_DELETE_WINDOW SYSMON_close
 
      frame $SYSMON(DISPLAY).f1 -borderwidth 5 -relief ridge -bg blue
      pack $SYSMON(DISPLAY).f1 -side top -fill both -expand 1
      frame $SYSMON(DISPLAY).f1.f2 -relief flat -bg grey
      pack $SYSMON(DISPLAY).f1.f2 -side top -fill both -expand 1

      canvas $SYSMON(DISPLAY).f1.f2.c -yscrollcommand [ list $SYSMON(DISPLAY).f1.f2.yscroll set ] -borderwidth 0 -bg grey -height 450
      scrollbar $SYSMON(DISPLAY).f1.f2.yscroll -orient vertical -bg darkgrey -command [ list $SYSMON(DISPLAY).f1.f2.c yview ]
      frame $SYSMON(DISPLAY).f1.f2.c.f1 -bd 0 -bg grey
      $SYSMON(DISPLAY).f1.f2.c create window 0 0 -anchor nw -window $SYSMON(DISPLAY).f1.f2.c.f1
      bind $SYSMON(DISPLAY).f1.f2.c.f1 <Configure> [ list scrollbar_fixup $SYSMON(DISPLAY).f1.f2.c %w %h ]

      grid $SYSMON(DISPLAY).f1.f2.c -row 0 -column 0 -sticky news
      grid $SYSMON(DISPLAY).f1.f2.yscroll -row 0 -column 1 -sticky ns
      grid columnconfigure $SYSMON(DISPLAY).f1.f2 0 -weight 1
      grid rowconfigure $SYSMON(DISPLAY).f1.f2 0 -weight 1
  
      frame $SYSMON(DISPLAY).f2 -bg darkgrey
      button $SYSMON(DISPLAY).f2.b1 -text "Refresh" -width 6 -command SYSMON_refresh -bg darkgrey -font $font12
      button $SYSMON(DISPLAY).f2.b2 -text "Close" -width 6 -command SYSMON_close -bg darkgrey -font $font12
      pack $SYSMON(DISPLAY).f2.b1 -side left -padx 10 -pady 3
      pack $SYSMON(DISPLAY).f2.b2 -side right -padx 10 -pady 3
      pack $SYSMON(DISPLAY).f2 -side bottom 

      set SYSMON(CANVAS) $SYSMON(DISPLAY).f1.f2.c.f1

      set SYSMON(NODES) $selected_nodes
      set SYSMON(NODES,TODO) $SYSMON(NODES)
      set SYSMON(NODES,DONE) {}

      SYSMON_getData

    } else {
      raise $SYSMON(DISPLAY)
      bell -displayof .
    }
  } 
  update idletasks
}

#----------------------------------------------------------------------
proc stripBlank { inData } {

  set outData {}

  foreach item $inData {
    if { $item != {} } {
      lappend outData $item
    }
  }

  return $outData
}

#----------------------------------------------------------------------
proc HANDLE_findCentralNode { } {
  global centralnode suffix rcmd

  dputs "### HANDLE_findCentralNode"

  set return_list {}

  set centralNodeList [ split $centralnode ',' ]
  foreach node $centralNodeList {
    dputs "checking $node$suffix"
    set cmd "$rcmd ${node}${suffix} \"ps -o ucomm -A | grep -v grep | grep -w npm_main\" 2>@1 "
    set res2 [ exec_command $cmd ]
    if { [ lindex $res2 0 ] == 0 } {
      if { [ string equal "npm_main" [ lindex $res2 1 ] ] } {
        lappend return_list $node ONLINE
      } else {
        lappend return_list $node OFFLINE
      }
    } else {
      lappend return_list $node OFFLINE 
    }
  }
  return $return_list
}

#----------------------------------------------------------------------
proc HANDLE_checkDatasetFeedback { } {
  global HANDLE suffix exe_dir rcmd

  dputs "HANDLE_checkDatasetFeedback"

  # call filter_dataset script
  set filterCmd "$rcmd ${HANDLE(SELECTED_NODE)}${suffix} \"$exe_dir/filter_dataset \" 2>&1"
  puts "### filterCmd: $filterCmd"

  set res [ exec_command $filterCmd ]

  set txt ""
  set col red
  if { $HANDLE(NEW_OR_PREV) == "NEW" } {
    set tmpLine [ split [ lindex $res 1 ] \n ]
    foreach item $tmpLine {
      set txt "$txt$item\n"
    }

    if { [ string first $HANDLE(STR,SUCCESS) [ lindex $res 1 ] ] != -1 } {
      set txt "$txt\n\nHandle New Distribution was successful\n"
      set col green
    } else {
      # Anything else is a failure
      set txt "$txt\n\nHandle New Distribution has failed!\n"
    }
  } elseif { $HANDLE(NEW_OR_PREV) == "PREV" } {


  }
  display_message $txt $col
}

#----------------------------------------------------------------------
proc HANDLE_doDistribution { } {
  global HANDLE run_tools_path suffix 

  puts "HANDLE_performHandleDistribution ($HANDLE(NEW_OR_PREV)) ($HANDLE(SELECTED_NODE))"

  if { $HANDLE(NEW_OR_PREV) == "NEW" } {
    set handle_cmd "${run_tools_path}/com_lscm $HANDLE(SELECTED_NODE)${suffix} $HANDLE(STR,HANDLE_NEW)"
  } elseif { $HANDLE(NEW_OR_PREV) == "PREV" } {
    set handle_cmd "${run_tools_path}/com_lscm $HANDLE(SELECTED_NODE)${suffix} $HANDLE(STR,HANDLE_PREV)"
  }
  set res [ exec_command $handle_cmd ]

  HANDLE_close 

  if { [ lindex $res 1 ]  == 1 } {
    display_message "Error with $HANDLE(STR,HANDLE_NEW) on node $HANDLE(SELECTED_NODE)${suffix}:\n[ lindex $res 1 ]" red
  } else {
    HANDLE_checkDatasetFeedback 
  }
}

#----------------------------------------------------------------------
proc HANDLE_close { } {
  global HANDLE

  catch { destroy $HANDLE(DISPLAY) }
  set HANDLE(DISPLAY) -1
  
}

#----------------------------------------------------------------------
proc HANDLE_datasetSelection { } {
  global font12 HANDLE

  dputs "### HANDLE_datasetSelection:"

  if { $HANDLE(DISPLAY) == -1 } {

    # Some error checking
    set list_of_central_nodes [ HANDLE_findCentralNode ]
    puts "list_of_central_nodes($list_of_central_nodes)"
    if { [ llength $list_of_central_nodes ] < 2 } {
      display_message "Error - cannot find any CENTRAL nodes" red
      return
    }

    set found_one_online 0
    foreach {node state} $list_of_central_nodes {
      if { [ string equal $state "ONLINE" ] } {
        set found_one_online 1
        set HANDLE(SELECTED_NODE) $node
        break
      }
    }
    if { $found_one_online == 0 } {
      set txt "No central node online. Please start one of the following nodes are try again:"
      foreach { node state } $list_of_central_nodes {
        set txt "$txt\n\t* $node"
      }
      display_message $txt red
      return
    }

    set HANDLE(DISPLAY) .sysMngWin
    set HANDLE(NEW_OR_PREV) NEW

    toplevel $HANDLE(DISPLAY) -bg darkgrey
    wm geometry $HANDLE(DISPLAY) +460+0
    wm title $HANDLE(DISPLAY) "DATASET TOOLS"
    wm resizable $HANDLE(DISPLAY) 0 0
    wm protocol $HANDLE(DISPLAY) WM_DELETE_WINDOW HANDLE_close

    frame $HANDLE(DISPLAY).f1 -borderwidth 5 -relief ridge -bg green
    pack $HANDLE(DISPLAY).f1 -side top -fill both -expand 1
    frame $HANDLE(DISPLAY).f1.f2 -relief flat -bg darkgrey
    pack $HANDLE(DISPLAY).f1.f2 -side top -fill both -expand 1

    frame $HANDLE(DISPLAY).f1.f2.f3 -bd 2 -relief groove -bg darkgrey
    label $HANDLE(DISPLAY).f1.f2.f3.l1 -text "Select Dataset Handling: "
    radiobutton $HANDLE(DISPLAY).f1.f2.f3.r1 -text "Handle New Distribution" -font $font12 -fg black \
                                -bg darkgrey -variable HANDLE(NEW_OR_PREV) -value NEW
    radiobutton $HANDLE(DISPLAY).f1.f2.f3.r2 -text "Handle Previous Distribution" -font $font12 -fg black \
                                -bg darkgrey -variable HANDLE(NEW_OR_PREV) -value PREV
    pack $HANDLE(DISPLAY).f1.f2.f3.l1 -side top -padx 5 -pady 5 -anchor n 
    pack $HANDLE(DISPLAY).f1.f2.f3.r1 -side top -padx 5 -pady 5 -anchor w
    pack $HANDLE(DISPLAY).f1.f2.f3.r2 -side top -padx 5 -pady 5 -anchor w
    pack $HANDLE(DISPLAY).f1.f2.f3 -side top -padx 5 -pady 5 -fill x -expand 1

    frame $HANDLE(DISPLAY).f1.f2.f4 -bd 2 -relief groove -bg darkgrey
    label $HANDLE(DISPLAY).f1.f2.f4.l1 -text "Select Central Node:"
    pack $HANDLE(DISPLAY).f1.f2.f4.l1 -side top -padx 5 -pady 5 -anchor n
    foreach {node state} $list_of_central_nodes {
      dputs "($node)($state)"
      radiobutton $HANDLE(DISPLAY).f1.f2.f4.r$node -text $node -font $font12 -fg black \
                                -bg darkgrey -variable HANDLE(SELECTED_NODE) -value $node
      pack $HANDLE(DISPLAY).f1.f2.f4.r$node  -side top -padx 5 -pady 5 -anchor w
      if { ! [ string equal $state "ONLINE" ] } {
        $HANDLE(DISPLAY).f1.f2.f4.r$node configure -state disabled -disabledforeground grey44
      }
    }
    pack $HANDLE(DISPLAY).f1.f2.f4 -side top -padx 5 -pady 5 -fill x -expand 1

    frame $HANDLE(DISPLAY).f2 -bg darkgrey
    button $HANDLE(DISPLAY).f2.b1 -text "Apply" -width 8 -command HANDLE_doDistribution -bg darkgrey -pady 2 \
                                    -font $font12 -fg black -activebackground lemonchiffon1
    pack $HANDLE(DISPLAY).f2.b1 -side left -pady 5 -padx 10
    button $HANDLE(DISPLAY).f2.b2 -text "Cancel" -width 8 -command HANDLE_close -bg darkgrey -pady 2 \
                                    -font $font12 -fg black -activebackground lemonchiffon1
    pack $HANDLE(DISPLAY).f2.b2 -side right -pady 5 -padx 10
    pack $HANDLE(DISPLAY).f2 -side bottom -pady 3

  } else {
    bell -displayof .
    raise $DATASET(DISPLAY)
  }
} 

#----------------------------------------------------------------------
proc display_message_fatal { msg } {
  global font14hel

  dputs "### display_message: $msg"

  set msgWin .mwin
  catch { destroy $msgWin }
  toplevel $msgWin -bg grey
  wm geometry $msgWin +200+400
  wm title $msgWin "FATAL MESSAGE WINDOW"
  wm resizable $msgWin  0 0

  frame $msgWin.frmMsg -borderwidth 5 -relief ridge -bg red
  pack  $msgWin.frmMsg -side top -fill x

  frame $msgWin.frmMsg.fin -bd 2 -relief raised -bg grey90
  pack $msgWin.frmMsg.fin -side top -fill both -ipadx 20

  message $msgWin.frmMsg.fin.msg -aspect 500 -justify left -font $font14hel \
                                 -text "$msg" -fg black -bg grey90
  pack $msgWin.frmMsg.fin.msg -side top -pady 10
  button $msgWin.bclose -text "Close"  -width 6 -command { exit } \
                        -fg black -bg grey -font $font14hel -activebackground lemonchiffon1
  pack $msgWin.bclose
}

#----------------------------------------------------------------------
proc display_message { msg { col green } } {
  global font14hel

  dputs "### display_message: $msg"

  set msgWin .mwin
  catch { destroy $msgWin }
  toplevel $msgWin -bg grey 
  wm geometry $msgWin +200+400
  wm title $msgWin "MESSAGE WINDOW"
  wm resizable $msgWin  0 0
 
  frame $msgWin.frmMsg -borderwidth 5 -relief ridge -bg $col 
  pack  $msgWin.frmMsg -side top -fill x

  frame $msgWin.frmMsg.fin -bd 2 -relief raised -bg grey90 
  pack $msgWin.frmMsg.fin -side top -fill both -ipadx 20 
 
  message $msgWin.frmMsg.fin.msg -aspect 500 -justify left -font $font14hel \
                                 -text "$msg" -fg black -bg grey90 
  pack $msgWin.frmMsg.fin.msg -side top -pady 10 
  button $msgWin.bclose -text "Close"  -width 6 -command {destroy .mwin } \
                        -fg black -bg grey -font $font14hel \
                        -activebackground lemonchiffon1
  pack $msgWin.bclose
}

#----------------------------------------------------------------------
proc LOAD_loadSystem { } {
  global LOAD DATA font12 suffix

  dputs "### LOAD_loadSystem:"

  set LOAD(CENTRAL_NODES) {}
  set tmpList {}

  set LOAD(CENTRAL_NODES) [ HANDLE_findCentralNode ]
  puts "LOAD(CENTRAL_NODES) -> ($LOAD(CENTRAL_NODES))"
  if { [ llength $LOAD(CENTRAL_NODES) ] < 2 } {
    display_message "Error - cannot find any CENTRAL nodes on this partition ... !" red
    return
  }

  set LOAD(DISPLAY) .lstCentralNodes
  catch { destroy $LOAD(DISPLAY) }

  toplevel $LOAD(DISPLAY) -bg grey
  wm title $LOAD(DISPLAY) "SELECT NODE"
  wm resizable $LOAD(DISPLAY) 0 0
  wm protocol $LOAD(DISPLAY) WM_DELETE_WINDOW LOAD_close

  frame $LOAD(DISPLAY).f1 -borderwidth 5 -relief ridge -bg blue
  pack $LOAD(DISPLAY).f1 -side top -fill both -expand 1
  frame $LOAD(DISPLAY).f1.f2 -relief flat -bg grey
  pack $LOAD(DISPLAY).f1.f2 -side top -fill both -expand 1
 
  foreach { node state } $LOAD(CENTRAL_NODES) {
    button $LOAD(DISPLAY).f1.f2.b$node -text $node -width 28 -font $font12 -fg black \
                    -bg green -borderwidth 4 -activebackground lemonchiffon1 \
                    -command "LOAD_close ; LOAD_startCentralNode $node $state"
    pack $LOAD(DISPLAY).f1.f2.b$node -side top -padx 5 -pady 10 -ipady 2
  }

  button $LOAD(DISPLAY).bcancel -text "Cancel" -width 8 -command LOAD_close -bg darkgrey \
                                     -font $font12 -fg black -activebackground lemonchiffon1
  pack $LOAD(DISPLAY).bcancel -side bottom -padx 5 -pady 3

}

#----------------------------------------------------------------------
proc LOAD_close { } {
  global LOAD
  
  destroy $LOAD(DISPLAY)
  set LOAD(DISPLAY) -1

}

#----------------------------------------------------------------------
proc LOAD_startCentralNode { node state } {
  global LOAD run_tools_path suffix rcmd

  dputs "### LOAD_startCentralNode: $node $state"

  if { [ string equal $state "OFFLINE" ] } {
    set cmd "$rcmd ${node}${suffix} \"$run_tools_path/start node -silent >/dev/null 2>&1 </dev/null \" &"
    exec_command $cmd 
    LOAD_checkCentralNodeState $node
  } else {
    LOAD_applyLoadSystem $node
  }
}

#----------------------------------------------------------------------
proc LOAD_applyLoadSystem { node } {
  global exe_dir suffix rcmd
 
  dputs "### LOAD_applyLoadSystem: $node"

  set loadSysCmd "$rcmd ${node}${suffix} \"${exe_dir}/load_system $node load system \" &"
  exec_command $loadSysCmd

}

#----------------------------------------------------------------------
proc LOAD_checkCentralNodeState { node } {
  global suffix rcmd

  dputs "### LOAD_checkCentralNodeState $node"

  set checkCmd "$rcmd ${node}${suffix} \"ps -o ucomm -A | grep -v grep | grep npm_main\""
  set res [ exec_command $checkCmd ]

  if { [ string equal "npm_main" [ lindex $res 1 ] ] } {
    LOAD_applyLoadSystem $node
    return 
  } else {
    after 5000 LOAD_checkCentralNodeState $node
  }
}

#----------------------------------------------------------------------
#proc start_central_node { } {
#  global exe_dir cfg_dir suffix
#  global time_str m data_central_node font12hel
#  global DATA
#      
#  dputs "### start_central_node:"
#     
#  # Read the NODE_DESCRIPTION.AIF on the local node to determine the CENTRAL nodes
#  set list_of_central_nodes [ find_central_node ]
#
#  # check if local central node found belongs to the current Partition
#  set central_found "0"
#  foreach { centralnodename nodestate } $list_of_central_nodes {
#    if { [ lsearch -exact $DATA(NODES) $centralnodename ] != -1 } {
#      set central_found "1"
#      break
#    }
#  }
#
#     # If not, do the same check on first node of the current partition
#  if { $central_found == 0 } {
#    set nodename [ lindex $DATA(NODES) 0 ]
#    set list_of_central_nodes [ eval exec "rsh ${nodename}${suffix} \"cd /usr/system/INTEG/tksup/current/bin ; . ./tksup.profile ; find_central_node\" " ]
#  }
#
#  puts "### start_central_node: list_of_central_nodes = ($list_of_central_nodes)"
#
#  set word_count [llength $list_of_central_nodes]
#
#  if { $word_count >= 2 } { 
#
#    set win .lstCentralNodes
#    catch { destroy $win }
#
#    toplevel $win -bg grey
#    wm title $win "CHOOSE NODE"
#    wm resizable $win 0 0
#
#    frame $win.f1 -borderwidth 5 -relief ridge -bg blue
#    pack $win.f1 -side top -fill both
#    frame $win.f1.f2 -relief flat -bg grey
#    pack $win.f1.f2 -side top -fill both
# 
#    foreach { nodename nodestate } $list_of_central_nodes {
#      button $win.f1.f2.b$nodename -text $nodename -width 28 -font $font12hel -fg black \
#                    -bg green -borderwidth 4 -activebackground lemonchiffon1 \
#                    -command "destroy $win ; apply_start_central_node $nodename $nodestate"
#      pack $win.f1.f2.b$nodename -side top -padx 5 -pady 10 -ipady 2
#    }
#
#    button $win.bcancel -text "Cancel" -width 8 -command { destroy .lstCentralNodes } -bg darkgrey \
#                                     -font $font12hel -fg black -activebackground lemonchiffon1
#    pack $win.bcancel -side bottom
#
#  } else {
#    display_message "No central node found on this partition... !" blue
#  }
#}

#----------------------------------------------------------------------

#proc apply_start_central_node { central_node nodeStatus } {
#     global suffix run_tools_path
#
#     dputs "### apply_start_central_node: $central_node $nodeStatus"
#
#      if { [string compare $nodeStatus "OFFLINE" ] == 0} {
#           set rshSTARTCmd "rsh ${central_node}${suffix} \"$run_tools_path/start node -silent >/dev/null 2>&1 </dev/null \" &"
#           eval exec $rshSTARTCmd
#           check_centralNode_status $central_node
#      } else {
#           # Any of the following status returned by find_central_node should
#           # be considered as on-line. 
#           # ONLINE, BS_DNCSINGLE, BS_DNCMASTER
#            apply_load_system $central_node
#     }
#}
 
#----------------------------------------------------------------------
#proc perform_load_system { } {
#  global exe_dir selected_nodes suffix
#
#  dputs "### perform_load_system:"
#
#  set num_element [ llength $selected_nodes ]
#  if { $num_element == 0 } {
#    display_message "Please select a node to perform load system !" blue
#  } elseif { $num_element == 1 } {
#    foreach loadnode $selected_nodes {
#      set loadSysCmd "rsh ${loadnode}${suffix} \". .profile; ${exe_dir}/load_system $loadnode load system \" &"
#      eval exec $loadSysCmd
#    }
#  } else  {
#    display_message "Only one node is allowed in the list to perform load system." blue
#  } 
#}

#----------------------------------------------------------------------
proc ListTransferSelD {src dst y} {
  global selected_nodesD choicesD unselected_nodesD dual_node_list

  dputs "### ListTransferSelD: $src  $dst  $y"

  # Only have one node in the selected list at a time
  foreach i [ $src curselection ] {
    set value [ $src get $i ]

    if { $src == $choicesD } {
      set unselected_nodesD $dual_node_list
      set pos [ lsearch -exact $unselected_nodesD $value ]
      if { $pos != -1 } {
        set unselected_nodesD [ lreplace $unselected_nodesD $pos $pos ]
      }
      set selected_nodesD $value
    } else { # remove the only selected node
      set unselected_nodesD $dual_node_list
      set selected_nodesD {}
    }
  }
}

#----------------------------------------------------------------------
proc List_Select_DualNode { parent values } {
  global pickedD choicesD unselected_nodesD selected_nodesD 
  global font12 font14 

  dputs "### List_Select_DualNode: $parent $values"
  set unselected_nodesD $values
  set selected_nodesD {}
 
  #create two list side by side
  frame $parent -bg grey
 
  frame $parent.top -bg grey
  label $parent.top.l1 -text "Available Nodes" -bg grey -font $font14 -fg black
  label $parent.top.l2 -text "Selected Nodes" -bg grey -font $font14 -fg black
  set choicesD [ Scrolled_Listbox $parent.top.choices -font $font14 -width 15 -height 7 -bg grey -listvariable unselected_nodesD ]
  set pickedD [ Scrolled_Listbox $parent.top.picked -font $font14 -width 15 -height 7 -bg grey -listvariable selected_nodesD ]
  grid $parent.top.l1 -row 0 -column 0 -sticky w
  grid $parent.top.l2 -row 0 -column 1 -sticky w
  grid $parent.top.choices -row 1 -column 0
  grid $parent.top.picked -row 1 -column 1
  grid columnconfigure $parent.top 0 -weight 1
  grid columnconfigure $parent.top 1 -weight 1
  grid rowconfigure  $parent.top 1 -weight 1
  pack $parent.top -side top -fill both -padx 5 -pady 3

  frame $parent.bot -bg grey
  button $parent.bot.bCancel -text "Cancel" -width 10 -font $font14 -fg black \
                        -command {handle_usrwin .dualNodeWin "dual_nodes_inuse"} -bg darkgrey
  button $parent.bot.bSwitch -text "Switch" -width 10 -font $font14 -fg black \
                          -command { switch_dual_node } -bg darkgrey 
  pack $parent.bot.bSwitch -side left -padx 10
  pack $parent.bot.bCancel -side right -padx 10
  pack $parent.bot -side bottom -fill x -pady 3 -padx 5
 
  # selecting in choices moves items into picked and deletes that item from choices
  bind $choicesD <ButtonRelease-1> [list ListTransferSelD %W $pickedD %y]
 
  # selecting in picked moves items into choices ane deletes that item from picked
  bind $pickedD <ButtonRelease-1> [list ListTransferSelD %W $choicesD %y]
}

#----------------------------------------------------------------------
proc switch_dual_node { } {
  global selected_nodesD exe_dir

  dputs "### switch_dual_node:"
  set num_element [ llength $selected_nodesD ]

  if { $num_element == 0 } {
    display_message "Please select either a Master or Slave node from any pair of dual nodes !" blue
  } elseif { $num_element == 1 } {
    foreach node $selected_nodesD {
      LOG_write "Switching node: $node" W
      set cmd "${exe_dir}/switch_dual_nodes $node switch"
      exec_command $cmd
      update
    } 
  }
}

#----------------------------------------------------------------------
proc control_dual_node_switch { } {
  global selected_nodes dual_node_list 

  dputs "### control_dual_node_switch:"

  catch { destroy .dualNodeWin } 
  toplevel .dualNodeWin -bg grey
  wm title .dualNodeWin "SWITCH DUAL NODE"
  wm geometry .dualNodeWin +460+0
  wm resizable .dualNodeWin 0 0

  frame .dualNodeWin.f1 -borderwidth 5 -relief ridge -bg blue
  pack .dualNodeWin.f1 -side top -fill both
  frame .dualNodeWin.f1.f2 -bd 2 -relief raised -bg grey90
  pack .dualNodeWin.f1.f2 -side top -fill both

  # call List_select with the current frame and the list of node names
  List_Select_DualNode .dualNodeWin.f1.f2.cmdfrm  $dual_node_list
  pack .dualNodeWin.f1.f2.cmdfrm -side left -fill both -expand 1
 
}                

#----------------------------------------------------------------------
# issue STOP /START cmd to all selected nodes
# This routine makes a direct unix call to rsh to remotely open a shell and
# run the start / stop node commands are appropriate. Further
# the standart output and standart error channels are set to null, which
# forces the kernel to return with a handle to rsh

proc issuecmd { cmd } {
  global selected_nodes suffix run_tools_path start_cold_var rcmd

  dputs "### issuecmd: $cmd"

  if { [ string compare $cmd "START" ] == 0 } {
    if { $start_cold_var == 1 } {
      set option "-cold"
    } else {
      set option ""
    }      
    foreach node $selected_nodes {
      LOG_write "Starting node: $node ..please wait ..." W
      set cmd "$rcmd $node$suffix \"$run_tools_path/start node -silent $option >/dev/null 2>&1 </dev/null \" &" 
      exec_command $cmd
      update
    }
  } elseif { [ string compare $cmd "STOP" ] == 0 } {
    set num_element [ llength $selected_nodes ]
    if { $num_element == 0 } {
      display_message "Please select a node to perform stop !" blue
    } else {
      set answer [ tk_messageBox -message "Are you sure you want to perform stop ?"\
                                 -parent .cmd_window -type yesno -icon question ]
      switch -- $answer {
        yes { 
          foreach node $selected_nodes {
            LOG_write "Stopping node: $node ..." W
            set cmd "$rcmd $node$suffix \"cd $run_tools_path;./stop_node >/dev/null 2>&1 </dev/null \" &"
            exec_command $cmd
          }
        }
      }
    }
  } elseif { [ string compare $cmd "DATASET" ] == 0 } {
    HANDLE_datasetSelection
  } elseif { [ string compare $cmd "LOADSYS" ] == 0 } {
    LOAD_loadSystem
  } elseif { [ string compare $cmd "SWITCHDNC" ] == 0 } {
    control_dual_node_switch 
  }
}

#-------------------------------------------------------------------------------------------#

proc SelectAll {} {
  global unselected_nodes selected_nodes DATA

  dputs "### SelectAll:"

  set selected_nodes $DATA(NODES)
  set unselected_nodes {}
}

#-------------------------------------------------------------------------------------------#

proc DeSelectAll {} {
  global selected_nodes unselected_nodes DATA

  dputs "### DeSelectAll:"

  set unselected_nodes $DATA(NODES)
  set selected_nodes {}
}

############################################################################

proc original_weight { node_name } {
  global DATA

  dputs "### original_weight: $node_name"
  set res [ lsearch -exact $DATA(NODES) $node_name ] 
  return $res 
}
############################################################################

proc node_weight { value list_of_nodes } {
  global DATA

  dputs "### node_weight: $value  $list_of_nodes"

  set position 0 
  # find out the weight of the node based on its name and where it was positioned in the original list
  set SelNodeWeight [ original_weight $value ] 
 
  foreach x $list_of_nodes {
    set weight [ original_weight $x ]
    if { $weight >= $SelNodeWeight } {
      return $position
    } else {
      incr position
    } 	
  }
  return [ llength $DATA(NODES) ]  ; # the last entry in the original list 
}

##################################################################

# The variable i is the position of the curselection. ie selecting
# nodes from the first position in the list results in i=0
proc ListTransferSel { src dst y } {
  global selected_nodes choices unselected_nodes

  dputs "### ListTransferSel: $src $dst $y"

  set insert_pos 0
  foreach i [ $src curselection ] { ; # if there are more than one node selected
    set value [ $src get $i ]

    if { $src == $choices } {
      # find out where to insert this selected node
      set insert_pos [ node_weight $value $selected_nodes ]
      if { [ lsearch -exact $selected_nodes $value ] < 0 } {
        set selected_nodes [ linsert $selected_nodes $insert_pos $value ] 
      }
      set pos [ lsearch -exact $unselected_nodes $value ] 
      if { $pos >= 0 } {
        set unselected_nodes [ lreplace $unselected_nodes $pos $pos ]
      }
    } else {
      set insert_pos [ node_weight $value $unselected_nodes ]
      if { [ lsearch -exact $unselected_nodes $value ] < 0 } {
        # pdate the unselected_node list for proper sorting later
        set unselected_nodes [ linsert $unselected_nodes $insert_pos $value ]
      }
      set pos [ lsearch -exact $selected_nodes $value ]
      if { $pos >= 0 } {
        set selected_nodes [ lreplace $selected_nodes $pos $pos ]
      }
    }
  }
}

#---------------------------------------------------------------------------------
proc LAN_drawOPS { node } {
  global LAN

  set a [ lindex $LAN($node,POSITION) 0 ]
  set b [ lindex $LAN($node,POSITION) 1 ]
  set c [ lindex $LAN($node,POSITION) 2 ]
  set d [ lindex $LAN($node,POSITION) 3 ]

  set LAN(${node},LINE_OPS) [ $LAN(CANVAS) create line $a $b $c $b $d $b -width 5 -fill cyan ]
}

#---------------------------------------------------------------------------------
proc LAN_drawSRV { node } {
  global LAN

  set a [ expr [ lindex $LAN($node,POSITION) 0 ] + 30 ]
  set b [ expr [ lindex $LAN($node,POSITION) 1 ] + 20 ]
  set c [ lindex $LAN($node,POSITION) 2 ]
  set d [ lindex $LAN($node,POSITION) 3 ]
  set LAN(${node},LINE_SRV) [ $LAN(CANVAS) create line $a $b $c $b $d $b -width 5 -fill cyan ]
}

#---------------------------------------------------------------------------------
proc SWITCH_close { } {
  global SW_DATA

  dputs "### SWITCH_close"

  for { set iii 0 } { $iii < $SW_DATA(NUMBER_OF_SWITCH) } { incr iii } {
    if { $SW_DATA($iii,EVENT) != -1 } {
      after cancel $SW_DATA($iii,EVENT)
    }
    destroy $SW_DATA($iii,WINDOW)
    set SW_DATA($iii,STATE) INIT
  }

  destroy $SW_DATA(DISPLAY)
  set SW_DATA(DISPLAY) -1
}

#-----------------------------------------------------------------

proc SWITCH_closePortWindow { devIndex } {
  global SW_DATA

  dputs "### SWITCH_closePortWindow: $devIndex"

  after cancel $SW_DATA($devIndex,EVENT)
  destroy $SW_DATA($devIndex,WINDOW)
  SWITCH_resetData $devIndex $SW_DATA($devIndex,NAME) $SW_DATA($devIndex,IP)

}

#-----------------------------------------------------------------

proc SWITCH_closePortInfo { devIndex port } {
  global SW_DATA

  dputs "### SWITCH_closePortInfo: $devIndex $port"
  destroy $SW_DATA($devIndex,WINDOW).p$port
  set SW_DATA($devIndex,WINDOW).p$port ""
}

#-----------------------------------------------------------------

proc parse_bns_message { bns_name bns_event } {

  if { $bns_name == "ONLINE_UPGRADE_MODE_OPER" } {
    MUTED_checkState
  }

}

#-----------------------------------------------------------------
proc parse_trap_message { state dev port } {
  global SW_DATA

  dputs "# parse_trap_message dev($dev) port($port) state($state)"

  # No switch data stored (Monitor Network window not opened) so just ignore the message
  if { [ info exists SW_DATA ] == 0 } {
    dputs "No Monitor Network window open ... return"
    return
  }

  # Validate the data :
  # 1) check that we are monitoring the device (dev) and that its monitoring window is open, otherwise discard
  set devIndex -1
  for { set iii 0 } { $iii < $SW_DATA(NUMBER_OF_SWITCH) } { incr iii } {
    if { [ string equal -nocase $dev $SW_DATA($iii,NAME) ] == 1 } {
      set devIndex $iii
      break
    }
  }
  # Cannot find the correct device, just return and ignore the message
  if { $devIndex == -1 } {
    dputs "Cannot find correct device for message ... return"
    return
  }

  # Check to see that the device monitor is being displayed 
  if { [ string length $SW_DATA($devIndex,WINDOW) ] == 0 } {
    dputs "Device not open ... return"
    return
  }

  # Check that the port number is valid and one we are interested in 
  if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] == -1 } {
    dputs "Port number invalid ... return"
    return
  } 

  if { [ string equal -nocase "linkDown" $state ] } {
    set new_state 2 
  } elseif { [ string equal -nocase "linkUp" $state ] } {
    set new_state 1
  } else {
    dputs "Invalid link state ... return"
    return
  }

  if { $SW_DATA($devIndex,$port,IFOPERSTATUS,DATA) != $new_state } {
    set SW_DATA($devIndex,$port,IFOPERSTATUS,DATA) $new_state
    updatePortState $devIndex $port IFOPERSTATUS
  }
}

#-----------------------------------------------------------------------------------------
proc SWITCH_responds { devIndex } {
  global SW_DATA

  dputs "### SWITCH_responds: $devIndex"

  set devIP $SW_DATA($devIndex,IP)
  set res [ exec_command "/usr/bin/snmpbulkwalk -Oeq -r 0 -v 2c -c public $devIP ifNumber" ]
  if { [ lindex $res 0 ] != 0 } {
    puts "An error occurred with $devIP : [ lindex $res 1 ]"
    return 0
  }
  # Check to see if there was a timeout or other problem with getting the data from the switch
  if { [ string first "Timeout: No Response from" [ lindex $res 1 ] ] != -1 } {
    return 0
  }

  return [ lindex [ lindex $res 1 ] 1 ]
}

#-----------------------------------------------------------------------------------------

proc SWITCH_parseSnmp { devIndex river } {
  global SW_DATA

  set EOF 0

  dputs "## devIndex($devIndex) river($river)"

  if { $SW_DATA($devIndex,COUNTER) >= 100 } {
    set SW_DATA($devIndex,COUNTER) 0
    update idletasks
  } else {
    incr SW_DATA($devIndex,COUNTER) 
  }
 
  if { [ eof $river ] } {
    close $river
    set EOF 1
  } elseif { [ gets $river line ] < 0 } {
    return
  }

#puts "state($SW_DATA($devIndex,STATE))"

  switch -- $SW_DATA($devIndex,STATE) {
    INIT {
    }
    IFDESCR {
      if { ! $EOF } {
        # IF-MIB::ifDescr.10625 GigabitEthernet2/1/1
        # IF-MIB::ifDescr.10701 TenGigabitEthernet2/1/1
        # IF-MIB::ifDescr.48 FastEthernet0/48
        # IF-MIB::ifDescr.49 GigabitEthernet0/1
        set tmpStr [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        set SW_DATA($devIndex,$port,TEXT) $tmpStr
        lappend SW_DATA($devIndex,PORT_LIST) $port
        incr SW_DATA($devIndex,PORTS)
        set SW_DATA($devIndex,$port,IFNAME,TEXT) "Name"
        set SW_DATA($devIndex,$port,IFNAME,DATA) $port
        set SW_DATA($devIndex,$port,IFTYPE,TEXT) "Interface Type"
        set SW_DATA($devIndex,$port,IFTYPE,DATA) $tmpStr
      } else {
        # EOF reached, close the stream
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
#puts "($SW_DATA($devIndex,PORTS)) -> ($SW_DATA($devIndex,PORT_MAX))"
        # check that we have all the data
        if { $SW_DATA($devIndex,PORTS) == $SW_DATA($devIndex,PORT_MAX) } {
          set final_list [ list ]
          foreach port $SW_DATA($devIndex,PORT_LIST) {
            if { [ string match -nocase "*Ethernet*\/*" $SW_DATA($devIndex,$port,TEXT) ] } {
              lappend final_list $port
            } elseif { [ string match -nocase "*Serial*\/*" $SW_DATA($devIndex,$port,TEXT) ] } {
              # Need to add the serial port in as well - useful for routers!
              lappend final_list $port
            }
          }
          set SW_DATA($devIndex,PORT_LIST) $final_list
          dputs "final_list($SW_DATA($devIndex,PORT_LIST)"

          # We now have a clean list of ports, display them
          SWITCH_displaySnmpData $devIndex
          
          SWITCH_getSnmpData $devIndex IFALIAS

        } else {
          display_message "The $SW_DATA($devIndex,NAME) ($SW_DATA($devIndex,IP)) Network Device is not correctly responding to SNMP" red
        }
      }
    }
    IFALIAS {
      if { ! $EOF } {
        # IF-MIB::ifAlias.10001 orersvl1bsw2
        set tmpPort [ string range [ lindex $line 0 ] [ expr [ string last "." [ lindex $line 0 ] ] + 1 ] end ]
        set tmpStr [ string trim [ lrange $line 1 end ] ]
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $tmpPort ] != -1 } {
          set SW_DATA($devIndex,$tmpPort,IFALIAS,TEXT) "Description"
          set SW_DATA($devIndex,$tmpPort,IFALIAS,DATA) $tmpStr
        }

      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        SWITCH_getSnmpData $devIndex IFOPERSTATUS
      }
    }
    IFOPERSTATUS {
      if { ! $EOF } {
        # IF-MIB::ifOperStatus.11146 1 --> up
        # IF-MIB::ifOperStatus.11145 2+  --> down
        set state [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        set SW_DATA($devIndex,$port,IFOPERSTATUS,DATA) $state
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] != -1 } {
          updatePortState $devIndex $port IFOPERSTATUS
        }
      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        SWITCH_getSnmpData $devIndex IFNAME
      }
    }
    IFNAME {
      if { ! $EOF } {
        set state [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] != -1 } {
          set SW_DATA($devIndex,$port,IFNAME,DATA) $state
        }
      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        SWITCH_getSnmpData $devIndex IFSPEED
      }
    }
    IFSPEED {
      if { ! $EOF } {
        # IF-MIB::ifSpeed.11148 1000000000
        # IF-MIB::ifSpeed.11149 10000000
        # IF-MIB::ifSpeed.11201 4294967295
        set state [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] != -1 } {
          set SW_DATA($devIndex,$port,IFSPEED,DATA) [ expr $state / 1000000 ]
        }
      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        SWITCH_getSnmpData $devIndex IFMTU
      }
    }
    IFMTU {
      if { ! $EOF } {
        set state [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] != -1 } {
          set SW_DATA($devIndex,$port,IFMTU,DATA) $state
        }
      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        SWITCH_getSnmpData $devIndex IFPHYSADDRESS
      }
    }
    IFPHYSADDRESS {
      if { ! $EOF } {
        set state [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] != -1 } {
          set SW_DATA($devIndex,$port,IFPHYSADDRESS,DATA) [ string toupper $state ]
        }
      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        SWITCH_getSnmpData $devIndex IFADMINSTATUS
      }
    }
    IFADMINSTATUS {
      if { ! $EOF } {
        # IF-MIB::ifAdminStatus.11144 1 --> up
        # IF-MIB::ifAdminStatus.11150 2+ --> down
        set state [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        set SW_DATA($devIndex,$port,IFADMINSTATUS,DATA) $state
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] != -1 } {
          updatePortState $devIndex $port IFADMINSTATUS
        }
    
      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        SWITCH_getSnmpData $devIndex IFINDISCARDS
      }
    }
    IFINDISCARDS {
      if { ! $EOF } {
        set state [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] != -1 } {
          set SW_DATA($devIndex,$port,IFINDISCARDS,DATA) $state
        }
      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        SWITCH_getSnmpData $devIndex IFINERRORS
      }
    }
    IFINERRORS {
      if { ! $EOF } {
        set state [ lindex $line 1 ]
        set port [ lindex [ split [ lindex $line 0 ] "." ] 1 ]
        if { [ lsearch $SW_DATA($devIndex,PORT_LIST) $port ] != -1 } {
          set SW_DATA($devIndex,$port,IFINERRORS,DATA) $state
        }
      } else {
        set SW_DATA($devIndex,STREAM) -1
        set SW_DATA($devIndex,STREAM_PID) -1
        # Start an event to check the IFADMINSTATUS, IFINDISCARDS and IFINERRORS every 10 seconds
        set SW_DATA($devIndex,EVENT) [ after 10000 [ list SWITCH_getSnmpData $devIndex IFADMINSTATUS ] ]
      }
    }
    default {
      puts "Unknown state for switch $devIndex ($SW_DATA($devIndex,NAME)"
      return
    } 
  }
}

#-----------------------------------------------------------------------------------------

proc updatePortState { devIndex port status } {
  global SW_DATA dat_dir

  if { [ string length [ info command $SW_DATA($devIndex,WINDOW) ] ] != 0 } {
    if { [ string compare $status "IFADMINSTATUS" ] == 0 } {
      if { $SW_DATA($devIndex,$port,IFADMINSTATUS,DATA) != 1 } {
        $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2.b$port config -background grey -activebackground grey -bitmap @$dat_dir/discon_port.bmp
      }
    } else {
      if { $SW_DATA($devIndex,$port,IFOPERSTATUS,DATA) == 1 } {
        $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2.b$port config -background lightgreen -activebackground darkseagreen1 -bitmap @$dat_dir/con_port.bmp
      } else {
        $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2.b$port config -background yellow -activebackground orange -bitmap @$dat_dir/discon_port.bmp
      }
    }
  }
}

#-----------------------------------------------------------------------------------------

proc SWITCH_displaySnmpData { devIndex } {
  global SW_DATA dat_dir font12 font14

  dputs "### SWITCH_displaySnmpData: $devIndex"

  if { [ string length $SW_DATA($devIndex,WINDOW) ] == 0 } {

    set port_count [ llength $SW_DATA($devIndex,PORT_LIST) ]

    set SW_DATA($devIndex,NODES_PER_ROW) 8
    set SW_DATA($devIndex,WINDOW) .snmp$devIndex
    set SW_DATA($devIndex,PORT_DATA) .portdata${devIndex}
    set rem [ expr $port_count % $SW_DATA($devIndex,NODES_PER_ROW) ]
    if { $rem == 0 } {
      set SW_DATA($devIndex,NODES_PER_COL) [ expr $port_count / $SW_DATA($devIndex,NODES_PER_ROW) ]
    } else  {
      set SW_DATA($devIndex,NODES_PER_COL) [ expr $port_count / $SW_DATA($devIndex,NODES_PER_ROW) + 1 ]
    }
    set width [ expr $SW_DATA($devIndex,NODES_PER_ROW) * 60 + 120 ]
    set height [ expr $SW_DATA($devIndex,NODES_PER_COL) * 60 + 180 ]

    toplevel $SW_DATA($devIndex,WINDOW)
    wm title $SW_DATA($devIndex,WINDOW) "MONITORING $SW_DATA($devIndex,NAME) device $SW_DATA($devIndex,IP)"
    wm geometry $SW_DATA($devIndex,WINDOW) +200+400
    wm resizable $SW_DATA($devIndex,WINDOW) 0 1
    wm protocol $SW_DATA($devIndex,WINDOW) WM_DELETE_WINDOW [ list SWITCH_closePortWindow $devIndex ]

    frame $SW_DATA($devIndex,WINDOW).f1 -borderwidth 5 -relief ridge -bg green
    pack  $SW_DATA($devIndex,WINDOW).f1 -side top -fill both -expand 1
    frame $SW_DATA($devIndex,WINDOW).f1.f2 -borderwidth 5 -relief flat 
    pack  $SW_DATA($devIndex,WINDOW).f1.f2 -side top -fill both -expand 1

    scrollbar $SW_DATA($devIndex,WINDOW).f1.f2.yscroll -orient vertical -bg darkgrey -command [ list $SW_DATA($devIndex,WINDOW).f1.f2.c yview ]
    canvas $SW_DATA($devIndex,WINDOW).f1.f2.c -yscrollcommand [ list $SW_DATA($devIndex,WINDOW).f1.f2.yscroll set ] -borderwidth 0 -bg grey -height 450
    frame $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2 -bd 0 -bg grey
    $SW_DATA($devIndex,WINDOW).f1.f2.c create window 0 0 -anchor nw -window $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2

    bind $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2 <Configure> [ list scrollbar_fixup $SW_DATA($devIndex,WINDOW).f1.f2.c %w %h ]

    set myrow 0
    set mycol 0

    foreach port $SW_DATA($devIndex,PORT_LIST) {

      if { $mycol >= $SW_DATA($devIndex,NODES_PER_ROW) } {
        set mycol 0
        incr myrow
      }

      button $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2.b$port -bitmap @$dat_dir/discon_port.bmp -background grey \
                                          -font $font12 -command [ list SWITCH_showPortInfo $devIndex $port ] \
                                          -textvariable SW_DATA($devIndex,$port,IFNAME,DATA) -compound top
      grid $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2.b$port -in $SW_DATA($devIndex,WINDOW).f1.f2.c.frm2 -row $myrow -column $mycol -padx 2 -pady 2

      set SW_DATA($devIndex,DATA_FIELDS) [ list IFTYPE IFALIAS IFSPEED IFMTU IFPHYSADDRESS IFINDISCARDS IFINERRORS ]
      set SW_DATA($devIndex,$port,IFALIAS,TEXT) "Description"
      set SW_DATA($devIndex,$port,IFALIAS,DATA) "n/a"
      set SW_DATA($devIndex,$port,IFSPEED,TEXT) "Speed"
      set SW_DATA($devIndex,$port,IFSPEED,DATA) -1
      set SW_DATA($devIndex,$port,IFMTU,TEXT) "MTU"
      set SW_DATA($devIndex,$port,IFMTU,DATA) -1
      set SW_DATA($devIndex,$port,IFPHYSADDRESS,TEXT) "Physical Address"
      set SW_DATA($devIndex,$port,IFPHYSADDRESS,DATA) "00:00:00:00:00:00"
      set SW_DATA($devIndex,$port,IFINDISCARDS,TEXT) "Discarded Packets"
      set SW_DATA($devIndex,$port,IFINDISCARDS,DATA) -1
      set SW_DATA($devIndex,$port,IFINERRORS,TEXT) "Error packets"
      set SW_DATA($devIndex,$port,IFINERRORS,DATA) -1
      set SW_DATA($devIndex,$port,IFOPERSTATUS,TEXT) "IFOPERSTATUS"
      set SW_DATA($devIndex,$port,IFOPERSTATUS,DATA) -1
      set SW_DATA($devIndex,$port,IFADMINSTATUS,TEXT) "IFADMINSTATUS"
      set SW_DATA($devIndex,$port,IFADMINSTATUS,DATA) -1
      incr mycol
    }

    button $SW_DATA($devIndex,WINDOW).f1.f2.close -text "Close" -borderwidth 2 -font $font12 -command "SWITCH_closePortWindow $devIndex"

    pack $SW_DATA($devIndex,WINDOW).f1.f2.close -side bottom -pady 5
    pack $SW_DATA($devIndex,WINDOW).f1.f2.c -side left -fill both
    pack $SW_DATA($devIndex,WINDOW).f1.f2.yscroll -side right -fill y


  } else {
    bell -displayof .
    raise $SW_DATA($devIndex,WINDOW)
  }

}

#-----------------------------------------------------------------------------------------

proc SWITCH_showPortInfo { devIndex port } {
  global SW_DATA font14

  if { [ string length [ info command $SW_DATA($devIndex,WINDOW).p$port ] ] == 0 } {

    toplevel $SW_DATA($devIndex,WINDOW).p$port -bg grey -relief groove
    wm title $SW_DATA($devIndex,WINDOW).p$port "Device $SW_DATA($devIndex,NAME) Port $SW_DATA($devIndex,$port,IFNAME,DATA)"
    wm resizable $SW_DATA($devIndex,WINDOW).p$port 0 0
    wm protocol $SW_DATA($devIndex,WINDOW).p$port WM_DELETE_WINDOW [ list SWITCH_closePortInfo $devIndex $port ]

    frame $SW_DATA($devIndex,WINDOW).p$port.frm -borderwidth 5 -relief ridge -bg blue
    pack $SW_DATA($devIndex,WINDOW).p$port.frm -side top -expand 1 -fill both

    set tlp $SW_DATA($devIndex,WINDOW).p$port.frm

    set row 0
    foreach item $SW_DATA($devIndex,DATA_FIELDS) {
      frame $tlp.f$item -borderwidth 2 -relief raised -bg grey
      label $tlp.f$item.l1 -text [ format " %-20s :" $SW_DATA($devIndex,$port,$item,TEXT) ] -font $font14 -anchor w -bg darkgrey -justify left
      label $tlp.f$item.l3 -textvariable SW_DATA($devIndex,$port,$item,DATA) -font $font14 -anchor w -bg darkgrey -justify left 
      pack $tlp.f$item.l1 -side left 
      pack $tlp.f$item.l3 -side right -fill x -expand 1 
      pack $tlp.f$item -expand 1 -fill x
      incr row
   }

   button $SW_DATA($devIndex,WINDOW).p$port.close -bg darkgrey -text "Close" -font $font14 \
          -command [ list SWITCH_closePortInfo $devIndex $port ]
   pack $SW_DATA($devIndex,WINDOW).p$port.close -side bottom -pady 2

  } else {
    bell -displayof .
    raise $SW_DATA($devIndex,WINDOW).p$port
  }
}

#-----------------------------------------------------------------------------------------

proc SWITCH_manageSwitch { devIndex } {
  global SW_DATA

  dputs "### SWITCH_manageSwitch: $devIndex"

  if { [ string length [ info command $SW_DATA($devIndex,WINDOW) ] ] == 0 } {

    set result [ ping_node $SW_DATA($devIndex,IP) ]

    if { $result == 0 } {
      # Ok, we can ping the switch, check we can get data from it
      set number_of_interfaces [ SWITCH_responds $devIndex ]
      if { $number_of_interfaces == 0 } {
        display_message "The $SW_DATA($devIndex,NAME) ($SW_DATA($devIndex,IP)) Network Device is not responding to SNMP" red
      } else {
        # display switch data!
        set SW_DATA($devIndex,PORT_MAX) $number_of_interfaces
        SWITCH_getSnmpData $devIndex IFDESCR
      }
    } else {
      display_message "The $SW_DATA($devIndex,NAME) Network Device is not reachable at $SW_DATA($devIndex,IP) address" red
    }
  } else {
    bell -displayof .
    raise $SW_DATA($devIndex,WINDOW)
  }
}

#-----------------------------------------------------------------------------------------

proc SWITCH_getSnmpData { devIndex state } {
  global SW_DATA 

  dputs "SWITCH_getSnmpData $devIndex $state ($SW_DATA($devIndex,STREAM))($SW_DATA($devIndex,STREAM_PID))"

  if { $SW_DATA($devIndex,STREAM) != -1 } {
    puts "ERROR! SWITCH_getSnmpData request when there is another snmp request in progress!!!!!!"
    return
  }
  set SW_DATA($devIndex,STATE) $state
  set SW_DATA($devIndex,STREAM) [open "|/usr/bin/snmpbulkwalk -Oeq -r 0 -v 2c -c public $SW_DATA($devIndex,IP) $state 2>@1" r]
  set SW_DATA($devIndex,STREAM_PID) [ pid $SW_DATA($devIndex,STREAM)]
  fconfigure $SW_DATA($devIndex,STREAM) -blocking 0
  fileevent $SW_DATA($devIndex,STREAM) readable [ list SWITCH_parseSnmp $devIndex $SW_DATA($devIndex,STREAM) ]

}

#-----------------------------------------------------------------------------------------
proc LAN_initMonitorNodes { } {
  global LAN DATA

  set LAN(NODES) $DATA(NODES)
  foreach node $LAN(NODES) {
    set LAN($node,OPS) {}
    set LAN($node,SRV) {}
    set LAN($node,OPS,PING) -1
    set LAN($node,SRV,PING) -1
  }
}

#-----------------------------------------------------------------------------------------
proc LAN_monitorNodes { } {
  global LAN partname font12 dat_dir env

  dputs "### LAN_monitorNodes"

  if { $LAN(DISPLAY) == -1 } {

    set number_of_nodes [ llength $LAN(NODES) ]
    set quotient [ expr int($number_of_nodes / 3) ]
     # Allow 50 pixels per node with 180 for header/footer
    set height [ expr $quotient * 50 + 180 ]
    set button_offset 38

    set min_height $height
    if { $min_height > 500 } {
      set min_height 500
    }

    set nodelist1 [ lrange $LAN(NODES) 0 $quotient ]
    set nodelist2 [ lrange $LAN(NODES) [ expr $quotient + 1 ] [ expr ($quotient * 2) + 1 ] ]
    set nodelist3 [ lrange $LAN(NODES) [ expr ($quotient * 2) + 2 ] end ]

    set LAN(DISPLAY) .lan_top
    toplevel $LAN(DISPLAY) -bg grey
    wm title $LAN(DISPLAY) "$partname / Node Monitoring"
    wm protocol $LAN(DISPLAY) WM_DELETE_WINDOW LAN_close
    wm resizable $LAN(DISPLAY) false true
    wm minsize $LAN(DISPLAY) 850 [ expr $min_height + 100 ]

    frame $LAN(DISPLAY).f1 -borderwidth 5 -relief ridge -bg green
    pack $LAN(DISPLAY).f1 -side top -fill both -expand 1
    frame $LAN(DISPLAY).f1.f2 -bg grey
    pack $LAN(DISPLAY).f1.f2 -side top -fill both -expand 1

    frame $LAN(DISPLAY).f2 -bg grey
    button $LAN(DISPLAY).f2.b1 -text "Close" -width 7 -command LAN_close -bg darkgrey -font $font12
    button $LAN(DISPLAY).f2.b2 -text "Refresh" -width 7 -command LAN_refresh -bg darkgrey -font $font12

    set LAN(CANVAS) $LAN(DISPLAY).f1.f2.c
    canvas $LAN(CANVAS) -scrollregion [ list 0 0 850 $height ] -height $min_height -width 850 \
                        -borderwidth 0 -bg grey -relief sunken -yscrollcommand [ list $LAN(DISPLAY).f1.f2.yscroll set ]
    scrollbar $LAN(DISPLAY).f1.f2.yscroll -orient vertical -bg darkgrey -command [ list $LAN(CANVAS) yview ]

    grid $LAN(CANVAS) -row 0 -column 0 -sticky nsew
    grid $LAN(DISPLAY).f1.f2.yscroll -row 0 -column 1 -sticky nsew
    grid rowconfigure $LAN(DISPLAY).f1.f2 0 -weight 1

    pack $LAN(DISPLAY).f2.b1 -side right -padx 10 -pady 5
    pack $LAN(DISPLAY).f2.b2 -side left -padx 10 -pady 5
    pack $LAN(DISPLAY).f2 -side bottom -padx 10 -pady 5

    set h20 [ expr $height - 20 ]
    set h50 [ expr $height - 50 ]

    # Start drawing!

    # labels for OPS and SERVICE LAN
    $LAN(CANVAS) create text 0 20 -text "OPS LAN" -fill royalblue4 -anchor w -font $font12
    $LAN(CANVAS) create text 70 20 -text "SERVICE LAN" -fill steelblue3 -anchor w -font $font12

    # pick three points (a,b) (a,c) (a,d) to draw a straight line
    # Vertical
    $LAN(CANVAS) create line 80 40 80 $h50 80 $h50 -width 7 -fill steelblue3
    $LAN(CANVAS) create line 50 40 50 $h20 50 $h20 -width 7 -fill royalblue4

    # pick three points (a,b) (c,b) (d,b) to draw a straight line
    # Horizontally
    $LAN(CANVAS) create line 47 $h20 47 $h20 800 $h20 -width 7 -fill royalblue4
    $LAN(CANVAS) create line 77 $h50 77 $h50 800 $h50 -width 7 -fill steelblue3
  
    # Vertical
    if { [ llength $nodelist2 ] > 0 } {
      $LAN(CANVAS) create line 320 40 320 $h20 320 $h20 -width 7 -fill royalblue4
      $LAN(CANVAS) create line 350 40 350 $h50 350 $h50 -width 7 -fill steelblue3
    }
  
    # Vertical
    if { [ llength $nodelist3 ] > 0 } {
      $LAN(CANVAS) create line 590 40 590 $h20 590 $h20 -width 7 -fill royalblue4
      $LAN(CANVAS) create line 620 40 620 $h50 620 $h50 -width 7 -fill steelblue3
    }

    set cnt 0
    set posA 50
    set posB 60
    set posC 160
    foreach node $LAN(NODES) {

      set LAN(${node},POSITION) [ list $posA $posB $posC $posC ]
      set LAN(${node},LINE_OPS) -1
      set LAN(${node},LINE_SRV) -1

      button $LAN(CANVAS).b$node -bitmap @$dat_dir/node.bmp -fg blue -width 30 -height 30 -command "wm deiconify .top$node"
      if { [ string length [ info command .top$node ] ] == 0 } {
        $LAN(CANVAS).b$node configure -state disabled
      }
      label $LAN(CANVAS).l$node -text $node -width 12 -justify left -anchor w -font $font12
      incr posB 50
      $LAN(CANVAS) create window [ expr $posC + 15 ] [ expr $posB - $button_offset ] -window $LAN(CANVAS).b$node
      $LAN(CANVAS) create window [ expr $posC + 35 ] [ expr $posB - $button_offset ] -window $LAN(CANVAS).l$node -anchor w
 
      if { $cnt >= $quotient } {
        incr posA 270
        set posB 60
        incr posC 280
        set cnt 0
      } else {
        incr cnt
      }
    }

#    # Get the OPS and SERV lans from the current node's entry in /etc/hosts
#    # Messy as the basename can end in -li, -lis, -lix etc etc
#    # Alternative is to get the LAN_NAME and SVC_LAN_NAME env entries and grep the values in /etc/networks
#    # Slightly less messy
#    set ops_lan $env(LAN_NAME)
#    set service_lan $env(SVC_LAN_NAME)
#
#    set ops_lan_error [ catch { exec /bin/grep $ops_lan /etc/networks } res_out ]
#    if { $ops_lan_error != 1 } {
#      set OPS_LAN [ lindex [ stripBlank [ split $res_out ] ] 1 ].0
#    }
#
#    set srv_lan_error [ catch { exec /bin/grep $service_lan /etc/networks } res_out ]
#    if { $srv_lan_error != 1 } {
#      set SERV_LAN [ lindex [ stripBlank [ split $res_out ] ] 1 ].0
#    }
#
#    # check that there isnt an error with retrieving the ops or service lan details.
#    # If there is, then we dont use the bslan info
#    if { $ops_lan_error || $srv_lan_error } {
#      puts "Error with retrieving ops or service lan details ($ops_lan)($service_lan)"
#      LOG_write "Error with retrieving ops or service lan details ($ops_lan)($service_lan)" W
#    } else {
#      # if ops and svc are the same lan then just use one of them
#      if { $OPS_LAN == $SERV_LAN } {
#        set SERV_LAN "" 
#      }
#  
#      # -C   : No curses display (basic text only)
#      # -i 2 : Wait 2 seconds between sending packets
#      # -t 1 : TTL set to 1 (local network only)
#      # -L   : Suppress loopback of IPM packets
#      set LAN(STREAM) [open "|/usr/bin/bslan_monitor -C -i 2 -t 1 -L $OPS_LAN $SERV_LAN 2>@1" r]
#      set LAN(STREAM_PID) [ pid $LAN(STREAM) ]
#      fconfigure $LAN(STREAM) -blocking 0
#      fileevent $LAN(STREAM) readable { LAN_parseBslan [ gets $LAN(STREAM) ] }
#    }
#
    update idletasks

    LAN_updateDisplay

  } else {
    bell -displayof .
    raise $LAN(DISPLAY)
  }
}

#-----------------------------------------------------------------------------------------
#proc LAN_parseBslan { bslan_msg } {
#  global LAN localIdent suffix
#
#  dputs "### LAN_parseBslan ($bslan_msg)"
#
#  # Is the Monitor Nodes screen still available?
#  if { $LAN(DISPLAY) != -1 } {
#
#    set bslan_lst [ stripBlank [ split $bslan_msg " " ] ]
#    dputs "([llength $bslan_lst])((${bslan_lst}))"
#    # This will create a list similar to -> "ctercms01li: 56 bytes from cterfdp1ali: seq=12 time=3 ms"
#    # so we need to check that the 1st entry is the correct sending node (where tksup is running from
#    # and that the 5th entry is a node in our list
#    # Ignore anything else (ie switches, routers, unknown nodes to this partition)
#
#    # Need to ignore the first message from bslan_monitor
#    #ctercms01li: Master | ICMP [multiple] | (56 + 42) bytes x 1000 ms
#    if { [ string equal [ lindex $bslan_lst 1 ] "Master" ] == 1 } {
#      return
#    }
#
#    # Check hostname
#    set msg_host [ lindex $bslan_lst 0 ]
#    if { [ string equal -nocase -length [ string length $msg_host ] $msg_host $localIdent ] == 0 } {
#      return
#    }
#
#    # (end-1) is to remove the ":"
#    set msg_node [ string range [ lindex $bslan_lst 4 ] 0 end-1 ]
#
#    # see if this message is for the OPS or SERVICE lan
#    set whichlan OPS
#    if { [ string compare -length 1 [ string index $msg_node end ] $suffix ] == 0 } {
#      set msg_node [ string range $msg_node 0 end-1 ]
#      set whichlan SRV
#    }
#
#    # Check the node pinged is one we are monitoring on this partition
#    if { [ lsearch -exact $LAN(NODES) $msg_node ] == -1 } {
#      return
#    }
#
#    # If we are here then the host node is correct and the responding node is in our partition 
#    # update the key array with this node as "up" (-1 = unknown, 0 = down, 1+ = up)
#    # set value to 5 - this is decremented in update_monitor_node_display() every 1 second but refreshed here every 2 seconds
#    set LAN($msg_node,$whichlan,PING) 5
# }
#}

#-----------------------------------------------------------------------------------------
proc LAN_updateLineOPS { node col } {
  global LAN

  if { $LAN($node,LINE_OPS) == -1 } {
    LAN_drawOPS $node
  }
  $LAN(CANVAS) itemconfigure $LAN($node,LINE_OPS) -fill $col
}

#-----------------------------------------------------------------------------------------
proc LAN_updateLineSRV { node col } {
  global LAN
  if { $LAN($node,LINE_SRV) == -1 } {
    LAN_drawSRV $node
  } 
  $LAN(CANVAS) itemconfigure $LAN($node,LINE_SRV) -fill $col
}              

#-----------------------------------------------------------------------------------------
proc LAN_updateDisplay { } {
  global LAN

  dputs "### LAN_updateDisplay "

  # Is the Monitor Nodes screen still available?
  if { $LAN(DISPLAY) != -1 } {

    # Check each entry in the array for loss of connection
    foreach node $LAN(NODES) {
      if { $LAN($node,OPS,PING) != -1 } {
        incr LAN($node,OPS,PING) -1
      }
      if { $LAN($node,SRV,PING) != -1 } {
        incr LAN($node,SRV,PING) -1
      }
    }

    # Update the display every second
    foreach node $LAN(NODES) {
      if { [ string length [ info command .top$node ] ] == 0 } {
        $LAN(CANVAS).b$node configure -state disabled
      } else {
        $LAN(CANVAS).b$node configure -state normal
      }

      # Check the OPS lan - Should have 0,1 or 2 entries
      set olan_len [ llength $LAN($node,OPS) ]
      switch -- $olan_len {
         0 {
#             # We have nothing yet from ISUP so the node could be down or not started. Use the ICMP result instead
#             if { $LAN($node,OPS,PING) != -1 } {
#               $LAN(CANVAS) itemconfigure $LAN($node,LINE_OPS) -fill green
#             } else {
#               $LAN(CANVAS) itemconfigure $LAN($node,LINE_OPS) -fill red
#             }
         }
         1 {
             if { [ LAN_ethIsGood $LAN($node,OPS,[ lindex $LAN($node,OPS) 0 ]) ] } {
               LAN_updateLineOPS $node green
             } else {
               LAN_updateLineOPS $node red
             }
         }
         2 {
             set ethA $LAN($node,OPS,[ lindex $LAN($node,OPS) 0 ])
             set ethB $LAN($node,OPS,[ lindex $LAN($node,OPS) 1 ])

             # If the state of the interfaces is UNKNOWN then use the ICMP result instead
             if { $ethA == 102 && $ethB == 102 } {
               set result cyan
#               if { $LAN($node,OPS,PING) != -1 } {
#                 set result green
#               } else {
#                 set result red
#               }
             } else {
               # Check the status of each link - ideally one link should be operational and the other standby
               if { [ LAN_ethIsGood $ethA ] } {
                 if { [ LAN_ethIsGood $ethB ] } {
                   set result green
                 } else {
                   set result orange
                 } 
               } else {
                 if { [ LAN_ethIsGood $ethB ] } {
                   set result orange
                 } else {
                   set result red
                 }
               }
             }
             LAN_updateLineOPS $node $result
#             $LAN(CANVAS) itemconfigure $LAN($node,LINE_OPS) -fill $result
         }
         default {
           puts "LAN_updateDisplay : olan_len is $olan_len"
         }
      }

      # Check the standby lan - should have 0 or 1 entry
      set slan_len [ llength $LAN($node,SRV) ]
      switch -- $slan_len {
         0 {
#             # We have nothing yet from ISUP so the node could be down or not started. Use the ICMP result instead
#             if { $LAN($node,SRV,PING) != -1 } {
#               $LAN(CANVAS) itemconfigure $LAN($node,LINE_SRV) -fill green
#             } else {
#               $LAN(CANVAS) itemconfigure $LAN($node,LINE_SRV) -fill red
#             }
         }
         1 {
             # If the state of the interface is UNKNOWN then use the ICMP result instead
             set ethA $LAN($node,SRV,[ lindex $LAN($node,SRV) 0 ])
             if { $ethA == 102 } {
               set result cyan
#               if { $LAN($node,SRV,PING) != -1 } {
#                 set result green
#               } else {
#                 set result red
#               }
             } else {
               if { [ LAN_ethIsGood $ethA ] } {
                 set result green
               } else {
                 set result red
               }
             }
             LAN_updateLineSRV $node $result
#             $LAN(CANVAS) itemconfigure $LAN($node,LINE_SRV) -fill $result
         }
         default {
           puts "LAN_updateDisplay : slan_len is $slan_len"
         }
           

      }
    }

    after 1000 LAN_updateDisplay
  }
}

#--------------------------------------------------------------------------------
proc LAN_ethIsGood { state } {

#   #device states
#   set state(4_100) "OK         "
#   set state(4_101) "FAILED     "
#   set state(4_102) "UNKNOWN    "
#   set state(4_103) "IN USE     "
#   set state(4_104) "MAINTHALT  "
#   set state(4_105) "MAINTOFF   "
#   set state(4_106) "DETACHED   "
#   set state(4_107) "STARTING   "
#   set state(4_108) "STANDBY    "
#   set state(4_109) "OPERATIONAL"
#   set state(4_110) "TRANSMIT   "
#   set state(4_111) "READY      "
#   set state(4_112) "NOT OK     "

  if { $state == 100 || $state == 109 || $state == 110 | $state == 111 || $state == 108 } {
    return 1
  }
  return 0
}

#--------------------------------------------------------------------------------
proc LAN_ethIsStandby { state } {

  if { [ LAN_ethIsGood $state ] || $state == 108 } {
    return 1
  } else {
    return 0
  }
}

#--------------------------------------------------------------------------------
proc LAN_refresh { } {
  global LAN

  dputs "### LAN_refresh"

  foreach node $LAN(NODES) {
    $LAN(CANVAS) itemconfigure $LAN($node,LINE_OPS) -fill cyan
    $LAN(CANVAS) itemconfigure $LAN($node,LINE_SRV) -fill cyan
    set LAN($node,OPS,PING) -1
    set LAN($node,SRV,PING) -1
  }
}

#--------------------------------------------------------------------------------
proc LAN_close { } {
  global LAN

  dputs "### LAN_close:"

  if { $LAN(STREAM) != -1 } {
    close $LAN(STREAM)
    set LAN(STREAM) -1
  }
  if { $LAN(STREAM_PID) != -1 } {
    exec_command "kill -s SIGINT $LAN(STREAM_PID)"
    set LAN(STREAM_PID) -1
  }

  destroy $LAN(DISPLAY)
  set LAN(DISPLAY) -1

}

#--------------------------------------------------------------------------

#######################################################################
#
# ping specified node.
#
# return: 0   if ping response good
#         1   for all other cases
#
#######################################################################
proc ping_node { node } {
     
  dputs "### ping_node: $node"

  set res [ exec_command "/bin/ping -c 1 -w 1 $node" ]
  if { [ lindex $res 0 ] != 0 } { return 1 } 
  if { [ string first "abnormal" [ lindex $res 1 ] ] > -1 } { return 1 }
  if { [ string first "unknown" [ lindex $res 1 ] ] > -1 } { return 1 }
  # RH7.3 ping
  if { [ string first " 0% packet loss" [ lindex $res 1 ] ] > -1 } { return 0 }
  # RH9 ping
  if { [ string first " 0% loss" [ lindex $res 1 ] ] > -1 } { return 0 }

  return 1
 }

#-------------------------------------------------------------------

proc node_interface_status { node interface } {
  global exe_dir

  # Return values:
  # -1 : error or unreachable node
  # 0 : ok but no bonding
  # 1 : all ok
  # 2 : 1 interface down
  # 3 : 2 interfaces down
 
  # get status of bondx interface 
  set res [ exec_command "/bin/ping -c 1 -w 1 $node" ]
  if { [ lindex $res 0 ] != 0 } { return -1 }  
  set res [ exec_command "${exe_dir}/bond_if_stat $node $interface" ] 
  if { [ lindex $res 0 ] != 0 } { return -1 }

  # no bonding but up since we have an answer
  # when accessing through OPS interface
  if { [ string first "none" [ lindex $res 1 ] ] > -1 } { return 0 }
  # no up - bad
  if { [ string first "up" [ lindex $res 1 ] ] == -1 } { return 3 }
  # no down - good
  if { [ string first "down" [ lindex $res 1 ] ] == -1 } { return 1 }
  # one up - ok
  if { [ string first "up" [ lindex $res 1 ] ] > -1 } { return 2 }
  return -1
}

# --------------------------------------------------------------------------- 
proc user_cmd { }  {
  global node cmd_window_inuse node_list dual_node_list dat_dir
  global cfg_dir DATA

  dputs "### user_cmd:"

  if { [ string length [ info command .cmd_window ] ] == 0 } {

    toplevel .cmd_window -bg grey
    wm title .cmd_window "USER TOOLS"
    wm geometry .cmd_window +0+0
    wm resizable .cmd_window 0 0

    frame .cmd_window.f1 -borderwidth 5 -relief ridge -bg green
    pack .cmd_window.f1 -side top -fill both
    frame .cmd_window.f1.f2 -bd 2 -relief raised -bg grey90
    pack .cmd_window.f1.f2 -side top -fill both 

    List_Select .cmd_window.f1.f2.cmdfrm $DATA(NODES)
    pack .cmd_window.f1.f2.cmdfrm -side left -fill both -expand 1
  } else {
    raise .cmd_window
    bell -displayof .
  }
}

# --------------------------------------------------------------------------- 
proc handle_usrwin {w topWinInuse} {
  global cmd_window_inuse 
  global recNodes_inuse physical_mon_inuse 
  global dual_nodes_inuse
  
  dputs "### handle_usrwin: $w  $topWinInuse"

  destroy $w
  grab release $w
   
  #set the window already opened variable to 0
  set $topWinInuse 0 

}

# --------------------------------------------------------------------------- 
# reset all items when no response from isup
# --------------------------------------------------------------------------- 

proc reset_all_item {} {
  global node color state m time_str font12 font14
  global DRS ISUP MUTED

  dputs "### reset_all_item:"
  foreach i [array names node] {
    $m.$i.bnode_$i configure -background $color(2_27) -activebackground $color(2_27) -font $font14
    $m.$i.lnode_$i configure -text $state(2_27) -font $font14 
    $m.$i.ldnode_$i configure -text $state(3_56) -font $font14  
    global dev_$i
    foreach j [array names dev_${i}] {
      .top$i.f1.f2.c1.fn.bdev_$j configure -background $color(4_102) -activebackground $color(4_102)
      .top$i.f1.f2.c1.fn.ldev_$j configure -text $state(4_102) -font $font14 
    }
  }
  #
  set MUTED(NEWSTATE) -1
  MUTED_updateDisplay
  #
  set DRS(STATUS) -1
  #
  LOG_write "Refreshing Node and Device States ..." I
  puts $ISUP(STREAM) "SNAPSHOT2 "
  flush $ISUP(STREAM)
}

#----------------------------------------------------------------------------------
proc dev_win_state_command { win } {
    
  dputs "### dev_win_state_command: $win"

  # wm state $win will return the state of window
  # normal : open
  # withdraw : close 
  # iconic : iconify 
  set win_state  [wm state $win]
  if { [ string compare $win_state "withdrawn" ] == 0 } {
    wm deiconify $win 
    raise $win
  } elseif { [ string compare $win_state "normal" ] == 0 } {
    raise $win
  } else { ; # iconic
    wm deiconify $win 
    raise $win
  }
}

#----------------------------------------------------------------------------------
proc setupAlerts { } {
  global font12 font14 LOG
    
  dputs "### setupAlerts"

  if { [ string length [ info command .globalSetup ] ] == 0 } {     

    toplevel .globalSetup -bg darkgrey
    wm geometry .globalSetup +0+0
    wm title .globalSetup "ALERTS SETUP"
    wm resizable .globalSetup 0 0
    wm protocol .globalSetup WM_DELETE_WINDOW { destroy .globalSetup }
 
    frame .globalSetup.f1 -borderwidth 5 -relief ridge -bg blue
    pack .globalSetup.f1 -side top -fill x
    frame .globalSetup.f1.f2 -bd 2 -relief raised -bg grey
    pack .globalSetup.f1.f2 -side top -fill both -ipadx 20

    set base .globalSetup.f1.f2

    label $base.lab1 -text "Alert Level"
    pack $base.lab1 -side top -fill x

    frame $base.f3 -bd 2 -relief sunken -bg grey

    label $base.f3.lh1 -text "Fatal" -bg grey -font $font14 -anchor n
    label $base.f3.lh2 -text "Warning" -bg grey -font $font14 -anchor n
    label $base.f3.lh3 -text "Info" -bg grey -font $font14 -anchor n
    label $base.f3.lv1 -text "Log" -bg grey -font $font14 -anchor e
    label $base.f3.lv2 -text "Print" -bg grey -font $font14 -anchor e
    label $base.f3.lv3 -text "Online" -bg grey -font $font14 -anchor e
    label $base.f3.lv4 -text "Audible" -bg grey -font $font14 -anchor e
    label $base.f3.lv5 -text "" -bg grey -font $font14 -anchor e

    checkbutton $base.f3.cpf1 -bg grey -variable LOG(F,PRINT) -highlightthickness 0 -relief sunken
    checkbutton $base.f3.cpw2 -bg grey -variable LOG(W,PRINT) -highlightthickness 0 -relief sunken
    checkbutton $base.f3.cpi3 -bg grey -variable LOG(I,PRINT) -highlightthickness 0 -relief sunken
    checkbutton $base.f3.clf1 -bg grey -variable LOG(F,LOG) -state disabled -highlightthickness 0 -relief sunken
    checkbutton $base.f3.clw2 -bg grey -variable LOG(W,LOG) -state disabled -highlightthickness 0 -relief sunken
    checkbutton $base.f3.cli3 -bg grey -variable LOG(I,LOG) -state disabled -highlightthickness 0 -relief sunken
    checkbutton $base.f3.cof1 -bg grey -variable LOG(F,ONLINE) -highlightthickness 0 -relief sunken
    checkbutton $base.f3.cow2 -bg grey -variable LOG(W,ONLINE) -highlightthickness 0 -relief sunken
    checkbutton $base.f3.coi3 -bg grey -variable LOG(I,ONLINE) -highlightthickness 0 -relief sunken
    checkbutton $base.f3.ca  -bg grey -variable ALARM(ON) -highlightthickness 0 -relief sunken

    # Labels
    grid $base.f3.lh1 -row 0 -column 1 -sticky news -padx 5 -pady 3
    grid $base.f3.lh2 -row 0 -column 2 -sticky news -padx 5 -pady 3
    grid $base.f3.lh3 -row 0 -column 3 -sticky news -padx 5 -pady 3
    grid $base.f3.lv1 -row 1 -column 0 -sticky news -padx 5 -pady 3
    grid $base.f3.lv2 -row 2 -column 0 -sticky news -padx 5 -pady 3
    grid $base.f3.lv3 -row 3 -column 0 -sticky news -padx 5 -pady 3
    grid $base.f3.lv4 -row 4 -column 0 -sticky news -padx 5 -pady 3
    grid $base.f3.lv5 -row 5 -column 0 -sticky news -pady 3

    # checkboxes
    grid $base.f3.clf1 -row 1 -column 1 -sticky news 
    grid $base.f3.clw2 -row 1 -column 2 -sticky news 
    grid $base.f3.cli3 -row 1 -column 3 -sticky news
    grid $base.f3.cpf1 -row 2 -column 1 -sticky news
    grid $base.f3.cpw2 -row 2 -column 2 -sticky news
    grid $base.f3.cpi3 -row 2 -column 3 -sticky news
    grid $base.f3.cof1 -row 3 -column 1 -sticky news
    grid $base.f3.cow2 -row 3 -column 2 -sticky news
    grid $base.f3.coi3 -row 3 -column 3 -sticky news
    grid $base.f3.ca  -row 4 -column 1 -sticky news

    pack $base.f3 -side top -fill x -padx 5 -pady 3

    frame .globalSetup.f2  -bg darkgrey
    button .globalSetup.f2.but2 -text "Close" -width 6 -command { dumpAlerts ; destroy .globalSetup } \
                          -bg darkgrey -font $font12
    pack .globalSetup.f2.but2 -side right -padx 5 -pady 5
    pack .globalSetup.f2 -side bottom -padx 5 -pady 5

  } else {
    bell -displayof .
    raise .globalSetup
  }
}

#----------------------------------------------------------------------------------
proc dumpAlerts { } {
  global LOG ALARM

  puts "### Changing Alert Logging"
  puts "### FATAL: Print $LOG(F,PRINT), Log $LOG(F,LOG), Online $LOG(F,ONLINE), Audible $ALARM(ON)"
  puts "### Warn : Print $LOG(W,PRINT), Log $LOG(W,LOG), Online $LOG(W,ONLINE)"
  puts "### Info : Print $LOG(I,PRINT), Log $LOG(I,LOG), Online $LOG(I,ONLINE)"

  LOG_write "Changing Alert Logging" I
  LOG_write "FATAL: Print $LOG(F,PRINT), Log $LOG(F,LOG), Online $LOG(F,ONLINE), Audible $ALARM(ON)" F
  LOG_write "Warn : Print $LOG(W,PRINT), Log $LOG(W,LOG), Online $LOG(W,ONLINE)" F
  LOG_write "Info : Print $LOG(I,PRINT), Log $LOG(I,LOG), Online $LOG(I,ONLINE)" F
}

#----------------------------------------------------------------------------------
# exit properly

proc doExit {} {
  global exe_name 
  global DISCOVER LOG

  dputs "### doExit:"
  LOG_write "$exe_name exiting" W
  close $LOG(STREAM)

  if { $DISCOVER(STREAM_PID) != -1 } {
    exec_command "kill -s SIGINT $DISCOVER(STREAM_PID)"
  }

  puts "### $exe_name: exiting"
  exit
}

#----------------------------------------------------------------------------------
 
proc DISCOVER_getNetmask { } {
  global font12 font14
  global DISCOVER
 
  dputs "### DISCOVER_getNetmask"

  if { $DISCOVER(DISPLAY) == -1 } {
    set DISCOVER(STREAM) -1
    set DISCOVER(STREAM_PID) -1
    set DISCOVER(LOG) ""
    set DISCOVER(E1) 255
    set DISCOVER(E2) 255
    set DISCOVER(E3) 255
    set DISCOVER(E4) 0

    set DISCOVER(DISPLAY) .netSetup
    toplevel $DISCOVER(DISPLAY) -bg darkgrey
    wm geometry $DISCOVER(DISPLAY) +0+0
    wm title $DISCOVER(DISPLAY) "DISCOVER NETWORK"
    wm resizable $DISCOVER(DISPLAY) 0 1
    wm protocol $DISCOVER(DISPLAY) WM_DELETE_WINDOW DISCOVER_closeNetSearch
 
    frame $DISCOVER(DISPLAY).f1 -borderwidth 5 -relief ridge -bg green
    pack $DISCOVER(DISPLAY).f1 -side top -fill both -expand 1
    frame $DISCOVER(DISPLAY).f1.f2 -bd 2 -relief raised -bg grey90
    pack $DISCOVER(DISPLAY).f1.f2 -side top -fill both -ipadx 20 -expand 1

    frame $DISCOVER(DISPLAY).f1.f2.f3 -bg grey90
    label $DISCOVER(DISPLAY).f1.f2.f3.lab1 -text "Subnet" -padx 0 -bg grey -font $font12
    label $DISCOVER(DISPLAY).f1.f2.f3.dot1 -text "." -padx 0 -bg grey -font $font12
    label $DISCOVER(DISPLAY).f1.f2.f3.dot2 -text "." -padx 0 -bg grey -font $font12
    label $DISCOVER(DISPLAY).f1.f2.f3.dot3 -text "." -padx 0 -bg grey -font $font12
    entry $DISCOVER(DISPLAY).f1.f2.f3.e1 -width 4 -relief sunken -font $font12 -bg white -fg black -textvariable DISCOVER(E1) \
                                -validate all -validatecommand { expr { [ string length %P ] <= 3 } }
    entry $DISCOVER(DISPLAY).f1.f2.f3.e2 -width 4 -relief sunken -font $font12 -bg white -fg black -textvariable DISCOVER(E2) \
                                -validate all -validatecommand { expr { [ string length %P ] <= 3 } }
    entry $DISCOVER(DISPLAY).f1.f2.f3.e3 -width 4 -relief sunken -font $font12 -bg white -fg black -textvariable DISCOVER(E3) \
                                -validate all -validatecommand { expr { [ string length %P ] <= 3 } }
    entry $DISCOVER(DISPLAY).f1.f2.f3.e4 -width 4 -relief sunken -font $font12 -bg white -fg black -textvariable DISCOVER(E4) \
                                -validate all -validatecommand { expr { [ string length %P ] <= 3 } }

    frame $DISCOVER(DISPLAY).f1.f2.f4
    set DISCOVER(LOG) [eval {  text $DISCOVER(DISPLAY).f1.f2.f4.log -width 60 -height 8 -bg white -font $font14 -fg black \
                        -borderwidth 2 -relief sunken -setgrid true -yscrollcommand [list $DISCOVER(DISPLAY).f1.f2.f4.scroll set] } ]
    scrollbar $DISCOVER(DISPLAY).f1.f2.f4.scroll -orient vertical -bg darkgrey \
                -command [list $DISCOVER(DISPLAY).f1.f2.f4.log yview]
    $DISCOVER(LOG) insert end "\n"
    $DISCOVER(LOG) configure -state disabled

    pack configure $DISCOVER(DISPLAY).f1.f2.f4.scroll -side right -fill y
    pack $DISCOVER(DISPLAY).f1.f2.f4.log -side left -fill both -expand true

    pack $DISCOVER(DISPLAY).f1.f2.f3.lab1 -side left -padx 5
    pack $DISCOVER(DISPLAY).f1.f2.f3.e1 -side left
    pack $DISCOVER(DISPLAY).f1.f2.f3.dot1 -side left
    pack $DISCOVER(DISPLAY).f1.f2.f3.e2 -side left
    pack $DISCOVER(DISPLAY).f1.f2.f3.dot2 -side left
    pack $DISCOVER(DISPLAY).f1.f2.f3.e3 -side left 
    pack $DISCOVER(DISPLAY).f1.f2.f3.dot3 -side left
    pack $DISCOVER(DISPLAY).f1.f2.f3.e4 -side left

    pack $DISCOVER(DISPLAY).f1.f2.f3 -side top -fill x -padx 5 -pady 3
    pack $DISCOVER(DISPLAY).f1.f2.f4 -side top -fill both -padx 5 -pady 3 -expand 1

    set DISCOVER(START) [  button $DISCOVER(DISPLAY).but1 -text "Search" -width 6 -command DISCOVER_initNetSearch \
                          -bg darkgrey -font $font12 -disabledforeground grey44 ]
    set DISCOVER(STOP) [ button $DISCOVER(DISPLAY).but2 -text "Stop" -width 6 -command DISCOVER_stopNetSearch \
                          -bg darkgrey -font $font12 -state disabled -disabledforeground grey44 ]
    set DISCOVER(CLEAR) [ button $DISCOVER(DISPLAY).but3 -text "Clear" -width 6 -command DISCOVER_clearNetSearch \
                          -bg darkgrey -font $font12 -disabledforeground grey44 ]
    button $DISCOVER(DISPLAY).but9 -text "Close" -width 6 -command DISCOVER_closeNetSearch \
                          -bg darkgrey -font $font12

    pack $DISCOVER(DISPLAY).but1 -side left -padx 5 -pady 3
    pack $DISCOVER(DISPLAY).but2 -side left -padx 5 -pady 3
    pack $DISCOVER(DISPLAY).but3 -side left -padx 5 -pady 3
    pack $DISCOVER(DISPLAY).but9 -side right -padx 5 -pady 3

  } else {
    bell -displayof .
    raise $DISCOVER(DISPLAY)
  }
}                                                            

#----------------------------------------------------------------------------------
proc DISCOVER_stopNetSearch { } {
  global DISCOVER

  $DISCOVER(START) configure -state normal
  $DISCOVER(CLEAR) configure -state normal
  $DISCOVER(STOP) configure -state disabled

  if { $DISCOVER(STREAM) != -1 } {
    close $DISCOVER(STREAM)
    set DISCOVER(STREAM) -1 
  }
  if { $DISCOVER(STREAM_PID) != -1 } {
    exec_command "kill -s SIGINT $DISCOVER(STREAM_PID)"
    set DISCOVER(STREAM_PID) -1
  }
}

#----------------------------------------------------------------------------------
proc DISCOVER_clearNetSearch { } {
  global DISCOVER

  set DISCOVER(FOUND) {}
 
  $DISCOVER(LOG) configure -state normal
  $DISCOVER(LOG) delete 1.0 end
  $DISCOVER(LOG) insert end "\n"
  $DISCOVER(LOG) configure -state disabled

}

#----------------------------------------------------------------------------------
proc DISCOVER_closeNetSearch { } {
  global DISCOVER

  DISCOVER_stopNetSearch
  destroy $DISCOVER(DISPLAY)
  set DISCOVER(DISPLAY) -1
}
  

#----------------------------------------------------------------------------------
proc validTestA { netmask } {

  foreach item $netmask {
    if { [ string is integer -strict $item ] == 0 } {
      return 0
    }
  }
  return 1
}

proc validTestB { netmask } {
  foreach item $netmask {
    if { $item < 0 || $item > 255 } {
      return 0
    }
  }
  return 1
}

#----------------------------------------------------------------------------------
proc DISCOVER_validateSubnetMask { } {
  global DISCOVER

  set netmask [ list $DISCOVER(E1) $DISCOVER(E2) $DISCOVER(E3) $DISCOVER(E4) ]

  dputs "DISCOVER_validateSubnetMask netmask($netmask)"
  puts "DISCOVER_validateSubnetMask netmask($netmask)"

  # check that each is a number
  if { [ validTestA $netmask ] == 0 } {   
    display_message "Invalid subnet $DISCOVER(E1).$DISCOVER(E2).$DISCOVER(E3).$DISCOVER(E4)" red
    return 0 
  }
  if { [ validTestB $netmask ] == 0 } {
    display_message "Value must be between 0 and 255 " red
    return 0
  }
  set DISCOVER(NETMASK) "$DISCOVER(E1).$DISCOVER(E2).$DISCOVER(E3).$DISCOVER(E4)"

  return 1

}

#-------------------------------------------------------------------------
proc DISCOVER_initNetSearch { } {
  global DISCOVER

  set DISCOVER(FOUND) {}

  if { [ DISCOVER_validateSubnetMask ] } {
    set DISCOVER(STREAM) [open "|$DISCOVER(BSLAN_MONITOR) -C -i 3 -t 1 -L $DISCOVER(NETMASK) 2>@1" r]
    set DISCOVER(STREAM_PID) [ pid $DISCOVER(STREAM) ]
    fconfigure $DISCOVER(STREAM) -blocking 0
    fileevent $DISCOVER(STREAM) readable { DISCOVER_parseNetmask [ gets $DISCOVER(STREAM) ] }
    $DISCOVER(START) configure -state disabled 
    $DISCOVER(CLEAR) configure -state disabled 
    $DISCOVER(STOP) configure -state normal 
  }
}

#-------------------------------------------------------------------------
proc DISCOVER_parseNetmask { msg } {
  global DISCOVER localIdent DATA

  dputs "### DISCOVER_parseNetmask msg($msg)"

  if { $DISCOVER(DISPLAY) != -1 } {

    set netmask_lst [ stripBlank [ split $msg " " ] ]
    # Ignore the first line returned
    if { [ string equal [ lindex $netmask_lst 1 ] "Master" ] == 1 } {
      return
    }
    set msg_host [ lindex $netmask_lst 0 ]
    # ignore the line if we are getting info not originating from the local node
    if { [ string equal -nocase -length [ string length $msg_host ] $msg_host $localIdent ] == 0 } {
      return
    }
    # remove the ":" at the end of the node name
    set msg_node [ string range [ lindex $netmask_lst 4 ] 0 end-1 ]

    # check that the node name isnt part of the local partition
    # since the result could be the OPS or SRV name we need to check for both
    if { [ lsearch -exact $DATA(NODES) $msg_node ] == -1 && [ lsearch -exact $DATA(NODES) [ string range $msg_node 0 end-1 ] ] == -1 } {

      # check that we havent already added this node to the list
      if { [ lsearch -exact $DISCOVER(FOUND) $msg_node ] == -1 } {

#        # get the ip address from /etc/hosts
#        set res [ exec_command "/bin/grep $msg_node /etc/hosts" ]
#        if { [ lindex $res 0 ] == 0 } {
#          set msg_str "\t$msg_node\t..........\t[ lindex [ lindex $res 1 ] 0 ]\n"
#        } else {
          set msg_str "\t$msg_node\t..........\t$msg_node\n"
#        }
#
        # add the node to the list and display it
        lappend DISCOVER(FOUND) $msg_node
        $DISCOVER(LOG) configure -state normal
        $DISCOVER(LOG) insert end $msg_str
        $DISCOVER(LOG) see end
        $DISCOVER(LOG) configure -state disabled
      }
    }
  }
}

#-------------------------------------------------------------------------
proc ALARM_changeStatus { } {
  global ALARM

  set ALARM(COUNT) -1
  if { $ALARM(ON) } {
    LOG_write "Audio warnings : On" I
  } else {
    LOG_write "Audio warnings : Off" I
  }
}

#-------------------------------------------------------------------------

proc Menu_Bar { w } {
     global font12 font14 
     global DRS PRIV ALARM MODE REC

     dputs "### Menu_Bar: $w"
     set menuList { File Monitor Control System }

     frame $w -relief raised -bd 3 -borderwidth 2 -bg darkgrey
     pack $w -side left 
     # 
     foreach item $menuList {
         menubutton $w.menuBar$item -menu $w.menuBar$item.m -text $item \
                          -font $font14 -bg darkgrey -fg black \
                          -activebackground lemonchiffon1 -activeforeground blue 
         pack $w.menuBar$item -side left -padx 5 -ipadx 5 -ipady 3
         set m$item [menu $w.menuBar$item.m -tearoff 0 -borderwidth 2 \
                          -fg black  -bg darkgrey -font $font14 \
                          -activebackground lemonchiffon1 -activeforeground blue \
                          -disabledforeground grey49 ]
     }

     $mFile add command -label "About..." -command { displayInfo } -font $font14  
     $mFile add command -label Exit -command { doExit } -font $font14

     $mMonitor add command -label "Refresh Node States" -command { reset_all_item } -font $font14
     $mMonitor add command -label "Monitor Node Connections..." -command { LAN_monitorNodes } -font $font14
     $mMonitor add command -label "Monitor Network..." -command { SWITCH_setup } -font $font14
     if { $REC(AVAILABLE) == 1 } {
       $mMonitor add command -label "Recording Tools..." -command { runRecTool } -font $font14  
     }
     $mMonitor add command -label "Discover Nodes..." -command { DISCOVER_getNetmask } -font $font14  
     $mMonitor add command -label "Get Token" -command { TOKEN_confirmRequest } -font $font14 

     $mControl add command -label "Setup..." -command { setupAlerts } -font $font14 -state disabled
     $mControl add command -label "Printer Setup..." -command { PRINT_setup } -font $font14 -state disabled
     $mControl add command -label "User Tools..." -command { user_cmd } -font $font14 -state disabled
     $mControl add command -label "Mute/Unmute..." -command { MUTED_toggleState } -font $font14 -state disabled
     if { [ MODE_isAvailable ] } {
       $mControl add command -label "Mode Switch..." -command { MODE_switch } -font $font14 -state disabled
     }
     if { [ DRS_isDrsPartition ] } {
       $mControl add command -label "DRS Switch..." -command { DRS_performSwitch } -font $font14 -state disabled
     }

     $mSystem add command -label "login PRIV..." -command { PRIV_login } -font $font14
     $mSystem add command -label "logout PRIV" -command { PRIV_login } -font $font14 -state disabled
     set PRIV(menu_system) $mSystem
     set PRIV(menu_control) $mControl

     # map token status indicator in the same window
     TOKEN_statusIndicator $w
     ISUP_statusIndicator $w

     # GPS clock connection status
     globalClockIndicator $w

     if { [ DRS_isDrsPartition ] } {
       DRS_statusIndicator $w
     }

     PRIV_indicator $w

     MUTED_indicator $w
}

#-------------------------------------------------------------------------
proc MUTED_close_win { } {
  global MUTED

  catch { destroy $MUTED(win) }

}

#-------------------------------------------------------------------------
proc MUTED_toggleState { } {
  global MUTED font14hel

  puts "MUTED_toggleState"

  switch -- $MUTED(STATE) {
    0 {
      set newMutedState 1
    }
    1 {
      set newMutedState 0
    }
    default
    {
      display_message "MUTED state is currently UNKNOWN\nSwitching is unavailable" red
      return
    }
  }

  set MUTED(win) .drswin
  MUTED_close_win
  toplevel $MUTED(win) -bg grey
  wm geometry $MUTED(win) +200+400
  wm title $MUTED(win) "MUTED STATE SWITCH"
  wm resizable $MUTED(win)  0 0
  wm protocol $MUTED(win) WM_DELETE_WINDOW [ list MUTED_close_win ]

  frame $MUTED(win).f1 -borderwidth 5 -relief ridge -bg red
  pack  $MUTED(win).f1 -side top -fill both
  frame $MUTED(win).f1.f2 -relief flat -bg grey
  pack $MUTED(win).f1.f2 -side top -fill both

  label $MUTED(win).f1.f2.l1 -font $font14hel -fg black -bg grey \
    -text "Current partition state is [ MUTED_stateToString ]\n\nDo you want to switch it to [ MUTED_stateToString $newMutedState ]?"
  pack $MUTED(win).f1.f2.l1 -side top -fill both -expand 1 -padx 10 -pady 10
  button $MUTED(win).bcontin -text "Continue" -width 10 -command " MUTED_close_win ; MUTED_setState " \
    -fg black -bg grey -font $font14hel -activebackground lemonchiffon1
  button $MUTED(win).bclose -text "Close" -width 10 -command MUTED_close_win \
    -fg black -bg grey -font $font14hel -activebackground lemonchiffon1
  pack $MUTED(win).bcontin -side left -padx 10 -pady 5
  pack $MUTED(win).bclose -side right -padx 10 -pady 5

}

#-------------------------------------------------------------------------
proc MUTED_checkState { } {

  MUTED_getState
  MUTED_updateDisplay

}

#-------------------------------------------------------------------------
proc MUTED_getState { } {
  global MUTED DRS exe_dir

  set nname $DRS(ISUPNODE)
  if { [ string length $nname ] == 0 } {
    dputs "ISUPnode unknown ... using localhost"
    set nname localhost
  }

  set do_loop 3

  while { ${do_loop} >= 1 } {

    set res [ exec_command "${exe_dir}/ou_get_state $nname" ]
    # This should return "      ou_mode = 1"
  
    set MUTED(NEWSTATE) -1
    if { [ lindex $res 0 ] == 0 } {
      set tmp [ string trim [ lindex $res 1 ] ]
      if { [ string match "ou_mode = \[01\]" $tmp ] == 1 } {
        if { [ string is integer -strict [ string range $tmp 10 end ] ] } {
          set MUTED(NEWSTATE) [ string range $tmp 10 end ]
        }
      } 
    }
    if { $MUTED(NEWSTATE) == -1 } {
      puts "Error getting OU state, trying again"
      incr do_loop -1
      after 100
    } else {
      set do_loop 0
    }
  }
  
  dputs "DEBUG : MUTED_getState($MUTED(NEWSTATE))"

}

#-------------------------------------------------------------------------
proc MUTED_setState { } {
  global MUTED DRS exe_dir

  set nname $DRS(ISUPNODE)
  if { [ string length $nname ] == 0 } {
    dputs "ISUPnode unknown ... using localhost"
    set nname localhost
  }

  switch -- $MUTED(STATE) {
    0 {
        set newOUState 1
      }
    1 {
        set newOUState 0
      }
    default
      {
        display_message "ONLINE UPGRADE state is currently UNKNOWN\nSwitching is unavailable" red
        return
      }
  }
  set do_loop 3

  while { $do_loop >= 1 } {

    set res [ exec_command "${exe_dir}/ou_set_state $nname $newOUState" ]
    if { [ lindex $res 0 ] != 0 } {
      puts "Error setting OU state, trying again"
      incr do_loop -1
      after 100
    } else {
      set do_loop 0
    }
  }

  dputs "MUTED_setState ($res)"

}

#-------------------------------------------------------------------------
proc MUTED_indicator { win } {
  global MUTED

  frame $win.fmuted -bd 2 -bg grey -relief ridge
  pack $win.fmuted -side right

  label $win.fmuted.labeltxt -text "MODE:" -fg blue4 -bg grey
  pack $win.fmuted.labeltxt -side left -ipady 1

  set MUTED(LABEL) [ label $win.fmuted.labelstatus -text [ MUTED_stateToString ] -bd 1 -relief solid -bg [ MUTED_stateToColour ] -fg black -width 9 ]
  pack $win.fmuted.labelstatus -side right -ipadx 3 -padx 3
}

#-------------------------------------------------------------------------
proc MUTED_stateToString { { mstate -1 } } {
  global MUTED

  if { $mstate == -1 } {
    set mstate $MUTED(STATE)
  }

  switch -exact -- $mstate {
    0       { return "UNMUTED" }
    1       { return "MUTED" }
    default { return "UNKNOWN" }
  }
}

#-------------------------------------------------------------------------
proc MUTED_stateToColour { } {
  global MUTED

  switch -exact -- $MUTED(STATE) {
    0       { return green }
    1       { return purple }
    default { return cyan }
  }
}

#-------------------------------------------------------------------------
proc MUTED_updateDisplay { } {
  global MUTED

  dputs "DEBUG : MUTED_updateDisplay($MUTED(NEWSTATE))"

  if { $MUTED(NEWSTATE) != $MUTED(STATE) } {
    set MUTED(STATE) $MUTED(NEWSTATE)
    $MUTED(LABEL) configure -text [ MUTED_stateToString ] -bg [ MUTED_stateToColour ]
  }
}


#-------------------------------------------------------------------------
proc PRIV_indicator { win } {
  global PRIV

  frame $win.fpriv -bd 2 -bg grey -relief ridge
  pack $win.fpriv -side right

  label $win.fpriv.labeltxt -text "ACCESS:" -fg blue4 -bg grey
  pack $win.fpriv.labeltxt -side left -ipady 1

  set PRIV(label) [ label $win.fpriv.labelstatus -text "MONITOR" -bd 1 -relief solid -bg grey -fg black -width 9 ]
  pack $win.fpriv.labelstatus -side right -ipadx 3 -padx 3
}

#-------------------------------------------------------------------------
proc PRIV_toggle_menus { } {
  global PRIV

  if { $PRIV(STATE) == 1 } {
    $PRIV(menu_system) entryconfigure [ $PRIV(menu_system) index "login PRIV..." ] -state normal
    $PRIV(menu_system) entryconfigure [ $PRIV(menu_system) index "logout PRIV" ] -state disabled
    for { set iii 0 } { $iii <= [$PRIV(menu_control) index end ] } { incr iii } {
      $PRIV(menu_control) entryconfigure [ $PRIV(menu_control) index $iii ] -state disabled
    }
    foreach but $PRIV(buttons) {
      $but configure -state disabled
    }
    $PRIV(label) configure -bg grey -fg black -text "MONITOR" -width 9
    set PRIV(STATE)  0
  } else { 
    $PRIV(menu_system) entryconfigure [ $PRIV(menu_system) index "login PRIV..." ] -state disabled
    $PRIV(menu_system) entryconfigure [ $PRIV(menu_system) index "logout PRIV" ] -state normal
    for { set iii 0 } { $iii <= [ $PRIV(menu_control) index end ] } { incr iii } {
      $PRIV(menu_control) entryconfigure [ $PRIV(menu_control) index $iii ] -state normal
    }
    foreach but $PRIV(buttons) {
      $but configure -state normal
    }
    $PRIV(label) configure -bg red -fg black -text "CONTROL" -width 9
    set PRIV(STATE) 1
  }
}

#-------------------------------------------------------------------------
proc PRIV_login { } {
  global PRIV font14

  if { $PRIV(STATE) } {
    # Logged in as PRIV, just logout
    PRIV_toggle_menus
  } else {
    if { [ string length [ info command $PRIV(TOPLEVEL) ] ] == 0 } {
      set PRIV(TOPLEVEL) .topPriv
      toplevel $PRIV(TOPLEVEL) -bg darkgrey
      wm resizable $PRIV(TOPLEVEL) 0 0
      wm title $PRIV(TOPLEVEL) "ENTER PASSWORD"
      wm protocol $PRIV(TOPLEVEL) WM_DELETE_WINDOW PRIV_login_close
      frame $PRIV(TOPLEVEL).f1 -bd 5 -relief ridge -bg blue
      frame $PRIV(TOPLEVEL).f1.f2 -bd 5 -relief flat -bg grey
      pack  $PRIV(TOPLEVEL).f1 -side top 
      pack  $PRIV(TOPLEVEL).f1.f2 -side left

      label $PRIV(TOPLEVEL).f1.f2.l1 -text "Enter username and password" -justify left -bg darkgrey -font $font14
      pack $PRIV(TOPLEVEL).f1.f2.l1 -side top -fill x

      frame $PRIV(TOPLEVEL).f1.f2.f3 -bd 5 -relief flat -bg grey
      label $PRIV(TOPLEVEL).f1.f2.f3.l1 -text "Name :" -justify left -bg darkgrey -font $font14
      set PRIV(entry_name) [ entry $PRIV(TOPLEVEL).f1.f2.f3.e1 -justify left -font $font14 ]
      pack  $PRIV(TOPLEVEL).f1.f2.f3.l1 -side left -padx 4 -pady 4
      pack  $PRIV(TOPLEVEL).f1.f2.f3.e1 -side right -fill x -padx 8 -pady 4
      pack $PRIV(TOPLEVEL).f1.f2.f3 -side top -fill x

      frame $PRIV(TOPLEVEL).f1.f2.f4 -bd 5 -relief flat -bg grey
      label $PRIV(TOPLEVEL).f1.f2.f4.l1 -text "Pass :" -justify left -bg darkgrey -font $font14
      set PRIV(entry_pass) [ entry $PRIV(TOPLEVEL).f1.f2.f4.e1 -justify left -show "*" -font $font14 ]
      pack  $PRIV(TOPLEVEL).f1.f2.f4.l1 -side left -padx 4 -pady 4
      pack  $PRIV(TOPLEVEL).f1.f2.f4.e1 -side right -fill x -padx 8 -pady 4
      pack $PRIV(TOPLEVEL).f1.f2.f4 -side top -fill x

      button $PRIV(TOPLEVEL).f1.f2.b1 -bg darkgrey -font $font14 -text "OK" -command PRIV_validate -width 6
      button $PRIV(TOPLEVEL).f1.f2.b2 -bg darkgrey -font $font14 -text "Cancel" -command PRIV_login_close -width 6
      bind   $PRIV(TOPLEVEL).f1.f2.f4.e1 <KeyPress-Return> PRIV_validate
      bind   $PRIV(TOPLEVEL).f1.f2.f4.e1 <KeyPress-KP_Enter> PRIV_validate
      bind   $PRIV(TOPLEVEL).f1.f2.b1 <KeyPress-Return> PRIV_validate
      bind   $PRIV(TOPLEVEL).f1.f2.b1 <KeyPress-KP_Enter> PRIV_validate
      pack $PRIV(TOPLEVEL).f1.f2.b1 -side left -padx 4 -pady 4
      pack $PRIV(TOPLEVEL).f1.f2.b2 -side right -padx 4 -pady 4
    } else {
      bell -displayof .
      raise $PRIV(TOPLEVEL)
    }
  }
}

#-------------------------------------------------------------------------
proc PRIV_login_close { } {
  global PRIV

  destroy $PRIV(TOPLEVEL)
  set PRIV(TOPLEVEL) ""
}

#-------------------------------------------------------------------------

proc PRIV_validate { } {
  global PRIV exe_dir

  set short_name [ $PRIV(entry_name) get ]
  set pass [ $PRIV(entry_pass) get ]

  PRIV_login_close

  # Validate the name/password against PAM
  set res [ exec_command "${exe_dir}/chkpasswd tksup_${short_name} $pass" ]
  dputs "not_valid([ lindex $res 0 ]) --> [ lindex $res 1 ]"

  if { [ lindex $res 0 ] == 0 } {
    PRIV_toggle_menus
    LOG_write "User \"$short_name\" logged in" F
  } else {
    display_message "Invalid password" red
    LOG_write "Login attempt : invalid password for username \"$short_name\"" F
  }
}

#-------------------------------------------------------------------------
proc DRS_isDrsPartition { } {
  global DRS 

  return $DRS(PARTITION)
}

#-------------------------------------------------------------------------
proc DRS_isStatusValid { } {
  global DRS

  switch -exact -- $DRS(STATUS) {
    "0"     { return 1 }
    "1"     { return 1 }
    default { return 0 }
  }

}

#-------------------------------------------------------------------------
proc MODE_isAvailable { } {
  global MODE partname env

puts "partname($partname) env($env(PARTITION))"
  # The file may be there but check that the current partition is the same as what is passed 
  # as the argument.

  if { [ string equal $partname $env(PARTITION) ] && $MODE(AVAILABLE) == 1 } {
    return 1
  } else { 
    return 0
  }
}

#-------------------------------------------------------------------------
proc MODE_determineCurrentMode { } {
  global env MODE

  dputs "### MODE_determineCurrentMode"

  set check_a [ catch { set mode $env(SYSMNG_MODE) } check_b ]
  if { $check_a == 0 } {
    set MODE(CURRENT_MODE) $mode
  } else {
    set MODE(CURRENT_MODE) UNKNOWN
  }

}

#-------------------------------------------------------------------------
proc MODE_close { } {
  global MODE

  if { $MODE(DISPLAY) != -1 } {
    destroy $MODE(DISPLAY)
    set MODE(DISPLAY) -1
  }
}

#-------------------------------------------------------------------------
proc MODE_switch { } {
  global font12 font14 MODE

  dputs "### MODE_switch"

  if { $MODE(DISPLAY) == -1 } {
    set MODE(DISPLAY) .topSwitchMode
    toplevel $MODE(DISPLAY) -bg darkgrey
    wm title $MODE(DISPLAY) "SWITCH SSS MODE"
    wm resizable $MODE(DISPLAY) 0 0
    wm protocol $MODE(DISPLAY) WM_DELETE_WINDOW MODE_close 

    button $MODE(DISPLAY).b1 -text "Cancel" -width 10 -bg darkgrey -font $font12 \
                         -command MODE_close -fg black -bd 3
    frame $MODE(DISPLAY).f1 -bd 5 -relief ridge -bg green
    frame $MODE(DISPLAY).f1.f2 -relief flat -bg grey

#
    if { [ string equal $MODE(CURRENT_MODE) "SIMU" ] } {
      set txt "SIMU (current)"
    } else {
      set txt "SIMU"
    }
    button $MODE(DISPLAY).f1.f2.b1 -text $txt -width 30 -bg darkgrey -font $font14  \
                         -command  { MODE_checkModeSwitch SIMU } -fg black -bd 3 -padx 10
    pack $MODE(DISPLAY).f1.f2.b1 -side top -padx 5 -pady 3

#
    if { [ string equal $MODE(CURRENT_MODE) "OPER" ] } {
      set txt "OPER (current)"
    } else {
      set txt "OPER"
    }
    button $MODE(DISPLAY).f1.f2.b2 -text $txt -width 30 -bg darkgrey -font $font14 \
                         -command { MODE_checkModeSwitch OPER } -fg black -bd 3 -padx 10
    pack $MODE(DISPLAY).f1.f2.b2 -side top -padx 5 -pady 3

#    button $MODE(DISPLAY).f1.f2.b3 -text "T&E" -width 30 -bg darkgrey -font $font14 \
#                         -command { MODE_checkModeSwitch TE } -fg black -bd 3 -padx 10
#    pack $MODE(DISPLAY).f1.f2.b3 -side top -padx 5 -pady 3

    pack $MODE(DISPLAY).f1.f2 -side top -fill both -expand 1
    pack $MODE(DISPLAY).f1 -side top -fill both -expand 1
    pack $MODE(DISPLAY).b1 -side bottom -padx 3 -pady 5

  } else {
    bell -displayof .
    raise $MODE(DISPLAY)
  }

}

#-------------------------------------------------------------------------
proc MODE_checkModeSwitch { to_mode } {
  global MODE font24 font14

  dputs "### MODE_checkModeSwitch"

  MODE_close

  set MODE(NEXT_MODE) $to_mode
  if { $MODE(NEXT_MODE) == $MODE(CURRENT_MODE) } {
    display_message "SSS is already in mode $MODE(NEXT_MODE)!\nMode switch command rejected." red
    return
  }

  if { $MODE(DISPLAY) == -1 } {
    set MODE(DISPLAY) .topCheckMode
    toplevel $MODE(DISPLAY) -bg darkgrey
    wm resizable $MODE(DISPLAY) 0 0
    wm title $MODE(DISPLAY) "CHANGE MODE?"
    wm protocol $MODE(DISPLAY) WM_DELETE_WINDOW MODE_close 

    frame $MODE(DISPLAY).f1 -bd 5 -relief ridge -bg red
    pack $MODE(DISPLAY).f1 -side top -fill both
    frame $MODE(DISPLAY).f1.f2 -bd 5 -relief flat -bg grey
    pack $MODE(DISPLAY).f1.f2 -side left -fill both

    label $MODE(DISPLAY).f1.f2.l1 -justify center -bg darkgrey -fg red -font $font24 \
                        -text "WARNING!"
    label $MODE(DISPLAY).f1.f2.l2 -justify center -bg darkgrey -font $font14 \
                        -text "You are going to change the SSS mode from\n\
                               $MODE(CURRENT_MODE) to $MODE(NEXT_MODE).\n\n\
                               This will shutdown ALL the computers in the SSS\n\
                               and reconfigure them in $MODE(NEXT_MODE) mode.\n\n\
                               Are you sure you want to change modes?\n"

    button $MODE(DISPLAY).b1 -bg darkgrey -font $font14 -text "Confirm" -width 6 \
                         -command MODE_doSwitch 
    button $MODE(DISPLAY).b2 -bg darkgrey -font $font14 \
                     -text "Cancel" -command MODE_close -width 6

    pack $MODE(DISPLAY).f1.f2.l1 -side top -fill x -pady 4 -padx 4
    pack $MODE(DISPLAY).f1.f2.l2 -side top -fill x -pady 4 -padx 4
    pack $MODE(DISPLAY).b1 -side left -pady 4 -padx 14
    pack $MODE(DISPLAY).b2 -side right -pady 4 -padx 14
  } else {
    raise $MODE(DISPLAY)
    bell -displayof .
  }
}

#-------------------------------------------------------------------------
proc MODE_updateFileData { } {
  global MODE DATA

  set ret_val 1

  set MODE(OPER,SCRIPTS) {}
  set MODE(SIMU,SCRIPTS) {}

  foreach line $DATA(MODE) {
    # should have 4+ items on the line
    if { [ llength $line ] < 4 } {
      continue
    }
    # only check for OPER and SIMU 
    if { [ string equal [ lindex $line 0 ] "OPER" ] || [ string equal [ lindex $line 0 ] "SIMU" ] } {
      set this_mode [ lindex $line 0 ]
    } else {
      continue
    }
    set MODE($this_mode,VERSION) [ lindex $line 1 ]
    foreach script [ lrange $line 3 end ] {
      if { [ lsearch -exact $MODE($this_mode,SCRIPTS) $script ] == -1 } {
        lappend MODE($this_mode,SCRIPTS) $script
      }
    }
  }
  if { [ llength $MODE($MODE(NEXT_MODE),SCRIPTS) ] == 0 } {
    display_message "Error - cannot find any scripts to start for $MODE(NEXT_MODE) in switchmodefile!" red
    set ret_val 0
  }
  if { [ llength $MODE($MODE(CURRENT_MODE),SCRIPTS) ] == 0 } {
    display_message "Error - cannot find any scripts to stop for $MODE(CURRENT_MODE) in switchmodefile!" red
    set ret_val 0
  }

  return $ret_val
}

#-------------------------------------------------------------------------
proc MODE_buildOutputDisplay { } {
  global MODE font12

  set width 80
  set height 20

  set MODE(DISPLAY) .topCheckMode
  toplevel $MODE(DISPLAY) -bg darkgrey
  wm resizable $MODE(DISPLAY) 1 1
  wm title $MODE(DISPLAY) "SYSREF MONITORING WINDOW"
  wm protocol $MODE(DISPLAY) WM_DELETE_WINDOW MODE_close 
  wm minsize $MODE(DISPLAY) $width $height
 
  frame $MODE(DISPLAY).f1 -bd 5 -relief ridge -bg blue
  pack $MODE(DISPLAY).f1 -side top -fill both -expand 1
  frame $MODE(DISPLAY).f1.f2 -bd 5 -relief flat -bg grey
  pack $MODE(DISPLAY).f1.f2 -side left -fill both -expand 1

  set iii 0
  set disp $MODE(DISPLAY).f1.f2.f1
  set my_mode $MODE(CURRENT_MODE)
  frame $disp -bg darkgrey
  label $disp.l$iii -text $my_mode -bg grey -fg black
  grid $disp.l$iii -row $iii -column 0 -sticky w
  incr iii
  foreach script $MODE($my_mode,SCRIPTS) {
    label $disp.a$iii -text $script -bg darkgrey -fg black 
    set MODE(LABEL,$my_mode,$script,STOPPED) [ label $disp.b$iii -text "STOPPED" -bg darkgrey -fg grey ]
    grid $disp.a$iii -row $iii -column 1 -sticky w 
    grid $disp.b$iii -row $iii -column 2 -sticky w 
    incr iii
  }
  set my_mode $MODE(NEXT_MODE)
  label $disp.l$iii -text $my_mode -bg grey -fg black
  grid $disp.l$iii -row $iii -column 0 -sticky w
  incr iii
  foreach script $MODE($my_mode,SCRIPTS) {
    label $disp.a$iii -text $script -bg darkgrey -fg black
    set MODE(LABEL,$my_mode,$script,STOPPED) [ label $disp.b$iii -text "STOPPED" -bg darkgrey -fg grey ]
    set MODE(LABEL,$my_mode,$script,SETVER) [ label $disp.c$iii -text "SETVER" -bg darkgrey -fg grey ]
    set MODE(LABEL,$my_mode,$script,STARTED) [ label $disp.d$iii -text "STARTED" -bg darkgrey -fg grey ]
    grid $disp.a$iii -row $iii -column 1 -sticky w
    grid $disp.b$iii -row $iii -column 2 -sticky w
    grid $disp.c$iii -row $iii -column 3 -sticky w
    grid $disp.d$iii -row $iii -column 4 -sticky w
    incr iii
  }
  grid columnconfig $disp 5 -weight 1
  pack $disp -side top -anchor nw -fill x -ipadx 10 -ipady 10

  puts "[$disp configure]"
  
  frame $MODE(DISPLAY).f1.f2.f2 -bg darkgrey 
  set MODE(TEXT) [ eval { text $MODE(DISPLAY).f1.f2.f2.log -width $width -height $height -bg white -font $font12 -fg black \
                  -borderwidth 2 -relief sunken -setgrid true -yscrollcommand [ list $MODE(DISPLAY).f1.f2.f2.scroll set ] } ]
  scrollbar $MODE(DISPLAY).f1.f2.f2.scroll -orient vertical -bg darkgrey -command [ list $MODE(DISPLAY).f1.f2.f2.log yview ]
  pack $MODE(DISPLAY).f1.f2.f2.log -side left -fill both -expand 1
  pack $MODE(DISPLAY).f1.f2.f2.scroll -side right -fill y 

  frame $MODE(DISPLAY).f1.f2.f3 -bg darkgrey 
  set MODE(START_BUTTON) [ button $MODE(DISPLAY).f1.f2.f3.start -text "Start" -command MODE_start -fg black -bg grey \
                                 -font $font12 -activebackground lemonchiffon1 -disabledforeground grey44 ]
  set MODE(CLOSE_BUTTON) [ button $MODE(DISPLAY).f1.f2.f3.close -text "Close" -command MODE_close -fg black -bg grey \
                                 -font $font12 -activebackground lemonchiffon1 -disabledforeground grey44 ]
  pack $MODE(DISPLAY).f1.f2.f3.start -side left -pady 3 -padx 5 
  pack $MODE(DISPLAY).f1.f2.f3.close -side right -pady 3 -padx 5 
  
  pack $MODE(DISPLAY).f1.f2.f2 -side top -fill both -expand 1
  pack $MODE(DISPLAY).f1.f2.f3 -side bottom -fill x

  $MODE(TEXT) configure -state disabled

  parray MODE

}

#-------------------------------------------------------------------------
proc MODE_start { } {
  global MODE

  $MODE(START_BUTTON) configure -state disabled
   
  set MODE(STATE) STOP_NODES
  MODE_doSetverCommand
}

#-------------------------------------------------------------------------
proc MODE_doSwitch { } {
  global MODE

  MODE_close

  if { [ MODE_updateFileData ] == 0 } {
    return
  }
  # List of scripts to run to stop all the required nodes - all the CURRENT_MODE and NEXT_MODE
  set MODE(SCRIPTS_TO_RUN) [ concat $MODE($MODE(CURRENT_MODE),SCRIPTS) $MODE($MODE(NEXT_MODE),SCRIPTS) ]
  MODE_buildOutputDisplay
}

#-------------------------------------------------------------------------
proc MODE_updateLabel { script state col } {
  global MODE

  puts "MODE_updateLabel ($script)($state)($col)"
  puts "($MODE($MODE(CURRENT_MODE),SCRIPTS))"
  puts "(($MODE($MODE(NEXT_MODE),SCRIPTS)))"

  if { [ lsearch -exact $MODE($MODE(CURRENT_MODE),SCRIPTS) $script ] == -1 } {
    if { [ lsearch -exact $MODE($MODE(NEXT_MODE),SCRIPTS) $script ] == -1 } {
      # cant find the script so do nothing!
    } else {
      $MODE(LABEL,$MODE(NEXT_MODE),$script,$state) configure -fg $col
    }
  } else {
    $MODE(LABEL,$MODE(CURRENT_MODE),$script,$state) configure -fg $col
  }
}

#-------------------------------------------------------------------------
proc MODE_doSetverCommand { } {
  global MODE rcmd

  dputs "### MODE_doSetverCommand STATE($MODE(STATE))"
  puts "### MODE_doSetverCommand STATE($MODE(STATE))"
  
  # Use SYSREF to do the heavy lifting - stop the nodes for the current running system as well as the system we are going to.
  set cmd ""

  if { $MODE(STREAM) == -1 } {

    #
    # STOP_NODES,CHANGE_MODE (and maybe START_NODES) can probably be rolled into one "-node stopall -node fsetver -node start -doit" ??
    #
    # Stop all node in the CURRENT_MODE scripts
    # Stop all nodes in the NEXT_MODE scripts
    # Check the nodes in CURRENT_MODE and NEXT_MODE have stopped
    # Do setver on NEXT_MODE nodes
    # Start the NEXT_MODE nodes
    # 

    switch -- $MODE(STATE) {
      INIT {
      }
      STOP_NODES {
        if { [ llength $MODE(SCRIPTS_TO_RUN) ] > 0 } {
          set MODE(ACTIVE_SCRIPT) [ lindex $MODE(SCRIPTS_TO_RUN) 0 ]
          set MODE(SCRIPTS_TO_RUN) [ lrange $MODE(SCRIPTS_TO_RUN) 1 end ]
          set version $MODE($MODE(CURRENT_MODE),VERSION)
          set tool_name "${MODE(ACTIVE_SCRIPT)}.${version}_tool"
          set cmd "|$rcmd $MODE(SYSREF_HOST) -l sysref \"export service_lan_suffix=s ; /ref/sysref/mgt_tool_kit/partitions/${tool_name} -node stopall -list -doit\" 2>@1"
          MODE_updateLabel $MODE(ACTIVE_SCRIPT) STOPPED orange
        } else {
          # check that all the nodes have really stopped
          set MODE(SCRIPTS_TO_RUN) [ concat $MODE($MODE(CURRENT_MODE),SCRIPTS) $MODE($MODE(NEXT_MODE),SCRIPTS) ]
          set MODE(STATE) CHECK_STOPPED
          MODE_doSetverCommand
        }
      }
      CHECK_STOPPED {
        if { [ llength $MODE(SCRIPTS_TO_RUN) ] > 0 } {
          set MODE(NUMBER_OF_NODES) 0
          set MODE(NUMBER_OF_STOPPED_NODES) 0
          set MODE(ACTIVE_SCRIPT) [ lindex $MODE(SCRIPTS_TO_RUN) 0 ]
          set MODE(SCRIPTS_TO_RUN) [ lrange $MODE(SCRIPTS_TO_RUN) 1 end ]
          set version $MODE($MODE(CURRENT_MODE),VERSION)
          set tool_name "${MODE(ACTIVE_SCRIPT)}.${version}_tool"
          set cmd "|$rcmd $MODE(SYSREF_HOST) -l sysref \"export service_lan_suffix=s ; /ref/sysref/mgt_tool_kit/partitions/${tool_name} -node stopall -list -doit\" 2>@1"
        } else {
          set MODE(STATE) CHANGE_MODE
          # We just want the NEXT_MODE scripts to do the setver on
          set MODE(SCRIPTS_TO_RUN) $MODE($MODE(NEXT_MODE),SCRIPTS)
          MODE_doSetverCommand
        }
      }
      CHANGE_MODE {
        if { [ llength $MODE(SCRIPTS_TO_RUN) ] > 0 } {
          set MODE(ACTIVE_SCRIPT) [ lindex $MODE(SCRIPTS_TO_RUN) 0 ]
          set MODE(SCRIPTS_TO_RUN) [ lrange $MODE(SCRIPTS_TO_RUN) 1 end ]
          set version $MODE($MODE(NEXT_MODE),VERSION)
          set tool_name "${MODE(ACTIVE_SCRIPT)}.${version}_tool"
          set cmd "|$rcmd $MODE(SYSREF_HOST) -l sysref \"export service_lan_suffix=s ; /ref/sysref/mgt_tool_kit/partitions/${tool_name} -node fsetver -list -doit\" 2>@1"
          MODE_updateLabel $MODE(ACTIVE_SCRIPT) SETVER green
        } else {
          set MODE(STATE) START_NODES
          # only start the NEXT_MODE nodes
          set MODE(SCRIPTS_TO_RUN) $MODE($MODE(NEXT_MODE),SCRIPTS)
          MODE_doSetverCommand
        }  
      }
      START_NODES {
        if { [ llength $MODE(SCRIPTS_TO_RUN) ] > 0 } {
          set MODE(ACTIVE_SCRIPT) [ lindex $MODE(SCRIPTS_TO_RUN) 0 ]
          set MODE(SCRIPTS_TO_RUN) [ lrange $MODE(SCRIPTS_TO_RUN) 1 end ]
          set version $MODE($MODE(NEXT_MODE),VERSION)
          set tool_name "${MODE(ACTIVE_SCRIPT)}.${version}_tool"
          set cmd "|$rcmd $MODE(SYSREF_HOST) -l sysref \"export service_lan_suffix=s ; /ref/sysref/mgt_tool_kit/partitions/${tool_name} -node start -list -doit\" 2>@1"
          MODE_updateLabel $MODE(ACTIVE_SCRIPT) STARTED green
        } else {
          set MODE(STATE) INIT
          $MODE(CLOSE_BUTTON) configure -state normal
          set MODE(CURRENT_MODE) $MODE(NEXT_MODE)
          set MODE(NEXT_MODE) ""
        }  
      }
      default {
      }
    }

    if { [ string length $cmd ] > 0 } {
      MODE_displayText "--> $cmd"
      set MODE(STREAM) [ open $cmd r ]
      set MODE(STREAM_PID) [ pid $MODE(STREAM) ]
      fconfigure $MODE(STREAM) -blocking 0
      fileevent $MODE(STREAM) readable { MODE_parseSysref $MODE(STREAM) }
    }
  }
}

#-------------------------------------------------------------------------
proc MODE_displayText { txt } {
  global MODE

  if { $MODE(DISPLAY) != -1 } {
    $MODE(TEXT) configure -state normal
    $MODE(TEXT) insert end "$txt\n"
    $MODE(TEXT) see end
    $MODE(TEXT) configure -state disabled
  }
}
#-------------------------------------------------------------------------
proc MODE_parseSysref { river } {
  global MODE

  set EOF 0

  dputs "### MODE_parseSysref"

  if { [ eof $river ] } {
    close $river
    set EOF 1
puts "EOF FOUND!"
  } elseif { [ gets $river line ] < 0 } {
    return
  }

  switch -- $MODE(STATE) {
    INIT {
    }
    STOP_NODES {
      if { $EOF } {
        # EOF reached, close the stream
        set MODE(STREAM) -1
        set MODE(STREAM_PID) -1
        MODE_doSetverCommand
      } else {
        MODE_displayText $line
        if { [ string equal $line "Tasks over. Thanks. Bye!" ] } {
puts "FOUND ENDING"
        }
      }
    }
    CHECK_STOPPED {
      # Run the -node stop command again, but this time count the node and also count the "Is NOT running." and "Unable to reach the node" - they should match
      if { $EOF } {
        if { $MODE(NUMBER_OF_NODES) == $MODE(NUMBER_OF_STOPPED_NODES) } {
          MODE_updateLabel $MODE(ACTIVE_SCRIPT) STOPPED green
        }
        set MODE(STREAM) -1
        set MODE(STREAM_PID) -1
        MODE_doSetverCommand
      } else {
        MODE_displayText $line
        if { [ string match {Node * --------} $line ] } {
          incr MODE(NUMBER_OF_NODES)
        } elseif { [ string match {*Unable to reach the node *} $line ] } {
          incr MODE(NUMBER_OF_STOPPED_NODES)
        } elseif { [ string match {*Is NOT running.} $line ] } {
          incr MODE(NUMBER_OF_STOPPED_NODES)
        }
        if { [ string equal $line "Tasks over. Thanks. Bye!" ] } {
          puts "FOUND ENDING"
        }
      }
    }
    CHANGE_MODE {
      if { $EOF } {
        # EOF reached, close the stream
        set MODE(STREAM) -1
        set MODE(STREAM_PID) -1
        MODE_doSetverCommand
      } else {
        MODE_displayText $line
        if { [ string equal $line "Tasks over. Thanks. Bye!" ] } {
 puts "FOUND ENDING"
        }
      }
    }
    START_NODES {
      if { $EOF } {
        # EOF reached, close the stream
        set MODE(STREAM) -1
        set MODE(STREAM_PID) -1
        MODE_doSetverCommand
      } else {
        MODE_displayText $line
        if { [ string equal $line "Tasks over. Thanks. Bye!" ] } {
puts "FOUND ENDING"
        }
      }
    }
    default {
    }
  }
}

#-------------------------------------------------------------------------
proc DRS_statusIndicator { win } {
  global DRS

  dputs "### DRS_statusIndicator: $win"

  frame $win.fdrs -bd 2 -bg grey  -relief ridge
  pack $win.fdrs -side right

  label $win.fdrs.labeltxt -text "PARTITION STATE:" -fg blue4 -bg grey
  pack $win.fdrs.labeltxt -side left -ipady 1

  set DRS(LABEL) [ label $win.fdrs.labelstatus -text [ DRS_statusToString $DRS(STATUS) ] -bd 1 -relief solid -bg [ DRS_statusToColour ] -fg black ]
  pack $win.fdrs.labelstatus -side right -ipadx 3 -padx 3
}

#-------------------------------------------------------------------------
proc DRS_statusToString { { status -1 } } {
  global DRS 

  switch -exact -- $status {
    "0"     { return "DORMANT" }
    "1"     { return "ACTIVE" }
    default { return "UNKNOWN" }
  }
}

#-------------------------------------------------------------------------
proc DRS_statusToColour { } {
  global DRS
  switch -exact -- $DRS(STATUS) {
    "0"     { return yellow }
    "1"     { return green }
    default { return cyan }
  }
}

#-------------------------------------------------------------------------
proc DRS_updateStatus { } {
  global DRS exe_dir

  set nname $DRS(ISUPNODE)
  if { [ string length $nname ] == 0 } {
    dputs "ISUPnode unknown ... using localhost"
    set nname localhost
  }

  set res [ exec_command "${exe_dir}/drs_get_status $nname" ]
  # This shoud return "      drs_mode = 1"
 
  set DRS(STATUS) 0
  set tmp [ string trim [ lindex $res 1 ] ]
  if { [ string match "drs_mode = \[01\]" $tmp ] == 1 } {
    set DRS(STATUS) [ string range $tmp 11 end ]
  }

  dputs "DEBUG : DRS_updateStatus($DRS(STATUS))"

  DRS_updateDisplayedStatus
}

#-------------------------------------------------------------------------
proc DRS_performSwitch { } {
  global DRS font14hel

  if { [ DRS_isDrsPartition ] } {

    DRS_updateStatus
    
    switch -- $DRS(STATUS) {
      0 { 
          set newDrsStatus 1
        }
      1 { 
          set newDrsStatus 0
        }
      default
        {
          display_message "DRS status is currently UNKNOWN\nSwitching is unavailable" red
          return
        }
    }
    set currentDrsStatusStr [ DRS_statusToString $DRS(STATUS) ]
    set newDrsStatusStr [ DRS_statusToString $newDrsStatus ]

    set DRS(win) .drswin
    DRS_close_win
    toplevel $DRS(win) -bg grey
    wm geometry $DRS(win) +200+400
    wm title $DRS(win) "DRS SWITCH"
    wm resizable $DRS(win)  0 0
    wm protocol $DRS(win) WM_DELETE_WINDOW [ list DRS_close_win ]

    frame $DRS(win).f1 -borderwidth 5 -relief ridge -bg red
    pack  $DRS(win).f1 -side top -fill both
    frame $DRS(win).f1.f2 -relief flat -bg grey
    pack $DRS(win).f1.f2 -side top -fill both 

    label $DRS(win).f1.f2.l1 -font $font14hel -fg black -bg grey \
                                -text "Current partition state is $currentDrsStatusStr\n\nDo you want to switch it to $newDrsStatusStr ?"
    pack $DRS(win).f1.f2.l1 -side top -fill both -expand 1 -padx 10 -pady 10
    button $DRS(win).bcontin -text "Continue" -width 10 -command " DRS_close_win ; DRS_do_switch $newDrsStatus " \
                        -fg black -bg grey -font $font14hel -activebackground lemonchiffon1
    button $DRS(win).bclose -text "Close" -width 10 -command DRS_close_win \
                        -fg black -bg grey -font $font14hel -activebackground lemonchiffon1
    pack $DRS(win).bcontin -side left -padx 10 -pady 5
    pack $DRS(win).bclose -side right -padx 10 -pady 5

  }

}

#-------------------------------------------------------------------------
proc DRS_close_win { } {
  global DRS

  catch { destroy $DRS(win) }

}

#-------------------------------------------------------------------------
proc DRS_do_switch { newDrsStatus } {
  global DRS exe_dir

  set nname $DRS(ISUPNODE)
  if { [ string length $nname ] == 0 } {
    dputs "ISUPnode unknown ... using localhost"
    set nname localhost
  }
  exec_command "${exe_dir}/drs_set_status $nname $newDrsStatus" 

  set mess_str [ DRS_statusToString $newDrsStatus ]
  LOG_write "Setting local DRS status to $mess_str" W

  DRS_updateStatus 
}

#-------------------------------------------------------------------------
proc DRS_updateDisplayedStatus { } {
  global DRS

  if { [ DRS_isDrsPartition ] } {
    # Get current DRS status from the BNS
    set currentDrsStatusStr [ DRS_statusToString $DRS(STATUS) ]

    # update text
    $DRS(LABEL) configure -text $currentDrsStatusStr -bg [ DRS_statusToColour ]

  }
}

#-------------------------------------------------------------------------

proc displayInfo { } {
  global font12 font14
  global revision revDate

  dputs "### displayInfo:"

  set win .infoWin
  if { [ string length [ info command $win ] ] == 0 } {
    toplevel $win -bg grey
    wm geometry $win +460+0
    wm title $win "ABOUT TKSUP"
    wm resizable $win 0 0

    frame $win.frminfo -bd 5 -relief ridge -bg green
    pack $win.frminfo -side top -fill x
    set info_string "\n\
                      Tksup - TopSky-ATC(HE) Technical Supervision Tool\n\n\
                      [string trim ${revision} \$]\n\
                      [string trim ${revDate} \$]\n\n\
                      Support : topskyatc.support@thalesgroup.com.au\n\n\
                      \tCopyright @2002-2017 Thales Australia\t\n"
 
    label $win.frminfo.msg -font $font12 -wraplength 7i -justify left -text $info_string
    pack $win.frminfo.msg -side top

    button $win.bclose -text " Close " -width 8 -command { destroy .infoWin } -bg darkgrey \
                                        -font $font12 -fg black -activebackground lemonchiffon1
    pack $win.bclose -side bottom 
  } else {
    bell -displayof .
    raise $win
  }
}

#---------------------------------------------------------------------------------
# Update time_str variable and displayed time
#---------------------------------------------------------------------------------
proc refresh_time {time_label} {
     global time_str font12 font14

     set time_str [ clock format [ clock seconds ] -format "%H:%M:%S %d/%m/%y" ]
     $time_label configure -text $time_str -font $font12 
     pack $time_label
     after 1000 refresh_time $time_label
}

#----------------------------------------------------------------------------
# Info : Display the status of the global clock (ie GPS status)
#----------------------------------------------------------------------------
proc globalClockIndicator { win } {

  frame $win.fgclock -bd 2 -bg grey -relief ridge
  pack $win.fgclock -side right

  label $win.fgclock.labeltxt -text "CLOCK:" -fg blue4 -bg grey
  pack $win.fgclock.labeltxt -side left -ipady 1

  label $win.fgclock.lgclock -text "" -bd 1 -relief solid -bg cyan
  pack $win.fgclock.lgclock -side left -ipadx 10 -padx 3
}

#----------------------------------------------------------------------------

proc TOKEN_statusIndicator { win } {
     global font12cour

     dputs "### TOKEN_statusIndicator: $win"
     frame $win.fc -bd 2 -bg grey -relief ridge 
     pack $win.fc -side right 

     label $win.fc.labeltxt -text "TOKEN:" -fg blue4 -bg grey 
     pack $win.fc.labeltxt -side left -ipady 1

     label $win.fc.labelstatus -text "UNKNOWN" -bd 1 -relief solid -bg grey -fg darkgrey 
     pack $win.fc.labelstatus -side right -ipadx 3 -padx 3

}

#----------------------------------------------------------------------------
proc Message_Window { p } {
  global dat_dir font12 font14
  global color LOG
     
  dputs "### Message_Window: $p"

  frame $p -bd 2 -bg darkgrey -relief groove

  set LOG(TEXT) [ eval { text $p.log -width 120 -height 8 -bg white -font $font14 -fg black \
                  -borderwidth 2 -relief sunken -setgrid true -yscrollcommand [ list $p.scroll set ] } ]
  scrollbar $p.scroll -orient vertical -bg darkgrey -command [ list $p.log yview ]

  # Thales emblem
  #
  set im [ image create bitmap -file $dat_dir/thales.bmp -maskfile $dat_dir/thales.bmp \
                 -background white -foreground darkslateblue ]
  label $p.foo  -image $im -bg darkgrey
  pack $p.foo -side top
	
  set time_str "--:--:-- --/--/--"
  label $p.label2 -text $time_str -bg darkgrey -fg blue -font $font14
  pack $p.label2 -side top
  refresh_time $p.label2

  pack configure $p.scroll -side right -fill y
  pack $p.log -side left -fill both -expand true 

# after having done all the window setup above, set text color tag for log
  $p.log tag configure $color(I) -foreground black -background white
  $p.log tag configure $color(W) -foreground orange -background white
  $p.log tag configure $color(F) -foreground red -background white
}

#----------------------------------------------------------------------------
# set_tooltips gets a button's name and the tooltip string as
# arguments and creates the proper bindings for entering
# and leaving the button

proc set_tooltips {widget name} {

  dputs "### set_tooltips: $widget  $name"

  # first, restore it's native Button 1 capability
  bind $widget <Enter> "internal_tooltips_PopUp %W $name %X %Y"
  bind $widget <Leave> {internal_tooltips_PopDown %W}
}

#----------------------------------------------------------------------------
proc internal_tooltips_PopDown {widget} {
   
  dputs "### internal_tooltips_PopDown: $widget"

  catch {destroy .tooltips_wind}
  $widget configure -relief raised
}

#----------------------------------------------------------------------------
# internal_tooltips_PopUp is used to activate the tooltip window
proc internal_tooltips_PopUp {wid name X Y} {
     global font12 font14

  dputs "### internal_tooltips_PopUp: $wid  $name  $X  $Y"
  # get rid of other existing tooltips
  catch {destroy .tooltips_wind}
  toplevel .tooltips_wind

  # add a slight offset to make tooltips fall below cursor
  set Y [expr $Y+15]

  # Now pop up the new widgetLabel
  wm overrideredirect .tooltips_wind 1
  wm geometry .tooltips_wind +${X}+${Y}
  label .tooltips_wind.l -text $name -border 2 -relief raised -font $font12 
  pack .tooltips_wind.l -in .tooltips_wind
  .tooltips_wind.l configure -bg cyan 
}

#------------------------------------------------------------------------------
# Create Action Buttons at bottom of main window
#------------------------------------------------------------------------------

proc Action_Buttons { a } {
  global PRIV REC

  dputs "### Action_Buttons: $a"
  frame $a -bg grey

  lappend PRIV(buttons) [ button $a.btools -relief raised -bg darkgrey -text "User\nTools" -command user_cmd \
                          -state disabled -disabledforeground grey44 ]
  button $a.brefresh  -relief raised -bg darkgrey -text "Refresh\nNode States"      -command reset_all_item
  button $a.bmonNode  -relief raised -bg darkgrey -text "Monitor Node\nConnections" -command LAN_monitorNodes
  button $a.bmonNet   -relief raised -bg darkgrey -text "Monitor\nNetwork"          -command SWITCH_setup
  button $a.btoken    -relief raised -bg darkgrey -text "Get\nToken"                -command TOKEN_confirmRequest
  button $a.bQuit     -relief raised -bg darkgrey -text "Exit\nTKsup"               -command doExit             -fg red
  if { $REC(AVAILABLE) == 1 } {
    button $a.brecTools -relief raised -bg darkgrey -text "Recording\nTool"           -command runRecTool
    pack $a.btools $a.brefresh $a.bmonNode $a.bmonNet $a.btoken $a.brecTools $a.bQuit \
                  -ipadx 2 -ipady 2 -padx 2 -pady 2 -in $a -side left -fill both -expand 1
  } else {
    pack $a.btools $a.brefresh $a.bmonNode $a.bmonNet $a.btoken $a.bQuit \
       -ipadx 2 -ipady 2 -padx 2 -pady 2 -in $a -side left -fill both -expand 1
  }
}

#------------------------------------------------------------------------------

set dev_status 1
set dev_status_label "ATTACHED"

proc attach_detach_line { dev_win } {
  global exe_dir dev_status dev_status_label
  global suffix rcmd

  dputs "### attach_detach_line: $dev_win"
 
  set local_win $dev_win
  set split_buff [split $local_win "." ]                           ; # {} topcherdp04cda c1 fn bdev_extAFTN
  set tmp_node [ lindex $split_buff 1 ]                            ; # topcherdp04cda
  set tmp_dev  [ lindex $split_buff 6 ]                            ; # bdev_extAFTN
  regsub ^top $tmp_node {} node
  regsub ^bdev_ext $tmp_dev {} dev_to_attach_detach
  dputs "###     tmp_node: $tmp_node  node: $node"
  dputs "###     tmp_dev: $tmp_dev  dev_to_attach_detach: $dev_to_attach_detach"
 
  set dev_status_label [ .top${node}.f1.f2.c1.fn.ldev_${dev_to_attach_detach} cget -text ]
  set dev_status_label [ string range $dev_status_label 0 7 ]

  if { [ string compare $dev_status_label "DETACHED" ] == 0  } {
    # Set the device to UNKNOWN and let the state machine reinitialise the device
    set cmd "$rcmd ${node}${suffix} \"${exe_dir}/attach_detach_dev p ${node} unknown ${dev_to_attach_detach}\" &"
  } else { 
    set cmd "$rcmd ${node}${suffix} \"${exe_dir}/attach_detach_dev p ${node} detached ${dev_to_attach_detach}\" &" 
  } 
  exec_command $cmd
}  

#-----------------------------------------------------------------------
#  Get Token button handler
#-----------------------------------------------------------------------
proc TOKEN_confirmRequest { } {
  global partname localIdent 
  global TOKEN

  dputs "### TOKEN_confirmRequest: tokenState($TOKEN(STATE))"

  if { $TOKEN(STATE) == "REMOTE" } {
    TOKEN_FSM GET_REQUEST $partname $localIdent
  }
}

#-----------------------------------------------------------------------
#  TOKEN Finite State Machine
#-----------------------------------------------------------------------

proc TOKEN_FSM { tokenEvent fromPart eventIdent } {
     global localIdent partname time_str
     global TOKEN 

     dputs "### TOKEN_FSM: $tokenEvent $fromPart $eventIdent"
     dputs "###     tokenState($TOKEN(STATE)) tokenCounter($TOKEN(COUNTER))"

     if { $fromPart != $partname } {
         puts "### TOKEN_FSM: WARNING: token protocol error fromPart $fromPart ne partname $partname tokenEvent $tokenEvent tokenState($TOKEN(STATE))"
         return
     }

     set nextState $TOKEN(STATE)
     switch -- $TOKEN(STATE) {
         QUERYING {     ; # This STATE only used during TKsup startup.
            switch -- $tokenEvent {
               GET_REQUEST   {
                   after cancel $TOKEN(TIMERID)
                   puts $TOKEN(STREAM) "TOKEN $partname REQUEST $localIdent"
                   flush $TOKEN(STREAM)
                   set TOKEN(COUNTER) 0
                   set nextState REQUESTING
                   set TOKEN(TIMERID) [ after $TOKEN(RETRYTIME) TOKEN_FSM TIMER_EXPIRED $partname $localIdent ]
               }
               TIMER_EXPIRED {
                   if { $TOKEN(COUNTER) < $TOKEN(MAXTRIES) } {
                       puts $TOKEN(STREAM) "TOKEN $partname QUERY $localIdent"
                       flush $TOKEN(STREAM)
                       incr TOKEN(COUNTER)
                       set TOKEN(TIMERID) [ after $TOKEN(RETRYTIME) TOKEN_FSM TIMER_EXPIRED $partname $localIdent ]
                   } else {
                       set nextState LOCAL
                       set TOKEN(COUNTER) 0
                       LOG_write "TokenControl : LOCAL Token Assumed - No response from any other TKsup" W
                   }
               }
               RECV_QUERY    {
                   if { $eventIdent == $localIdent } {
                      # ignore our generated QUERY event
                   } else {
                      # QUERY from another TKsup in QUERYING state.
                      # Set TOKEN(STATE) to REMOTE to avoid multiple TKsups assuming LOCAL.
                      after cancel $TOKEN(TIMERID)
                      set nextState REMOTE
                      set TOKEN(COUNTER) 0
                      LOG_write "TokenControl : REMOTE Token Assumed - Other TKsups also starting." W
                   }
 
               }
               RECV_BUSY     {
                   after cancel $TOKEN(TIMERID)
                   set nextState REMOTE
                   set TOKEN(COUNTER) 0
                   LOG_write "TokenControl : REMOTE Token Assumed - TKsup $eventIdent has token." W
               }
               RECV_REQUEST  {
                   # ignore event
               }
               RECV_AVAIL    {
                   # ignore event
               }
            }
         }
         REMOTE {
            switch -- $tokenEvent {
               GET_REQUEST   {
                   puts $TOKEN(STREAM) "TOKEN $partname REQUEST $localIdent"
                   flush $TOKEN(STREAM)
                   set TOKEN(COUNTER) 0
                   set nextState REQUESTING
                   set TOKEN(TIMERID) [ after $TOKEN(RETRYTIME) TOKEN_FSM TIMER_EXPIRED $partname $localIdent ]
               }
               TIMER_EXPIRED {
                   # ignore event
               }
               RECV_QUERY    {
                   # ignore event
               }
               RECV_BUSY     {
                   # ignore event
               }
               RECV_REQUEST  {
                   # ignore event
               }
               RECV_AVAIL    {
                   # ignore event
               }
            }
         }
         REQUESTING {
            switch -- $tokenEvent {
               GET_REQUEST   {
                   # ignore event
               }
               TIMER_EXPIRED {
                   if { $TOKEN(COUNTER) < $TOKEN(MAXTRIES) } {
                       puts $TOKEN(STREAM) "TOKEN $partname REQUEST $localIdent"
                       flush $TOKEN(STREAM)
                       incr TOKEN(COUNTER)
                       set TOKEN(TIMERID) [ after $TOKEN(RETRYTIME) TOKEN_FSM TIMER_EXPIRED $partname $localIdent ]
                   } else {
                       set nextState LOCAL
                       set TOKEN(COUNTER) 0
                       LOG_write "TokenControl : LOCAL Token Assumed - No response from any other TKsup." W
                   }
               }
               RECV_QUERY    {
                   # ignore event
               }
               RECV_BUSY     {
                   # ignore event
               }
               RECV_REQUEST  {
                   # ignore event
               }
               RECV_AVAIL    {
                   if { $eventIdent == $localIdent } {
                       set nextState LOCAL
                       after cancel $TOKEN(TIMERID)
                       set TOKEN(COUNTER) 0
                       LOG_write "TokenControl : LOCAL Token Assumed - TKsup $eventIdent released token." W
                   } else {
                       after cancel $TOKEN(TIMERID)
                       set TOKEN(COUNTER) 0
                   }
               }
            }
         }
         LOCAL {
            switch -- $tokenEvent {
               GET_REQUEST   {
                   # ignore event
               }
               TIMER_EXPIRED {
                   # ignore event
               }
               RECV_QUERY    {
                   puts $TOKEN(STREAM) "TOKEN $partname BUSY $localIdent"
                   flush $TOKEN(STREAM)
               }
               RECV_BUSY     {
                   # ignore event
               }
               RECV_REQUEST  {
                   puts $TOKEN(STREAM) "TOKEN $partname AVAIL $eventIdent"
                   flush $TOKEN(STREAM)
                   set nextState REMOTE
                   LOG_write "TokenControl : REMOTE Token Assumed - TKsup $eventIdent requested token." W
               }
               RECV_AVAIL    {
                   # ignore event
               }
            }
         }
      }
      set TOKEN(STATE) $nextState

      # update displayed token status
      .wfm.fc.labelstatus configure -text $TOKEN(STATE)
      switch -- $TOKEN(STATE) {
          QUERYING   { .wfm.fc.labelstatus configure -bg yellow -fg black  }
          REMOTE     { .wfm.fc.labelstatus configure -bg grey  -fg black }
          LOCAL      { .wfm.fc.labelstatus configure -bg green -fg black  }
          REQUESTING { .wfm.fc.labelstatus configure -bg yellow -fg black  }
      }
}

#-----------------------------------------------------------------------

proc determineNodeStateAlert { node_state } {

  # Changes to the node messages - some messages are now considered ERRORS and some
  # as WARNINGS :
  # SHUTDOWN, EXITED : ERROR
  # UNKNOWN, SUSPEND : WARNING
  # OFFLINE, STARTING, ONLINE, RESIDENTONLY : INFORMATION

  switch -exact -- [ string trim $node_state ] {
    ONLINE -
    OFFLINE -
    UNKNOWN {
      return I
    }
    SHUTDOWN -
    EXITED {
      return F
    }
    default {
      return W
    }
  }
}

#-----------------------------------------------------------------------

proc determineDeviceStateAlert { device_state } {

  # Changes to the device messages - some messages are now considered WARNINGS
  # FAILED, UNKNOWN, DETACHED, NOT OK : WARNING
  # OK, IN USE, MAINTHALT, MAINTOFF, STARTING, STANDBY, OPERATIONAL, TRANSMIT, READY: INFORMATION

  switch -exact -- [ string trim $device_state ] {
    EXITED {
      return F
    }
    FAILED -
    DETACHED -
    {NOT OK} {
      return W
    }
    OK -
    STARTING -
    OPERATIONAL -
    STANDBY -
    OFFLINE -
    ONLINE -
    UNKNOWN {
      return I
    }
    default {
      return W
    }
  }
}

#-----------------------------------------------------------------------

proc parse_msg { msg_in } {
     global color node nb_node nb_dev state m max_height_devs max_height_nodes node_list
     global node_color device_table time_str first_column
     global count port dat_dir kanvas 
     global dev_number dual_node_list nodename
     global font12 font14 font14cour font12cour local_nodename status source
     global parttype 
     global partname min_width_nodes min_height_nodes
     global DRS LAN ISUP DATA

     dputs "### parse_msg: $msg_in"
     # part 0:
     # now using "mcat -s" to receive messages, which prepends the sending node name to the message. This
     # needs to be removed and saved as this can now be used to determine a "live" node (ie one where ubss is running)
     set DRS(ISUPNODE) [ string trim [ string range $msg_in 0 [ string first " " $msg_in ] ] ]
     # Remove the ISUPnode from the start of the message
     set msg [ string range $msg_in [ expr 1 + [ string first " " $msg_in ] ] end ]

     # part 1:
     #
     # Check received message/event if it can be passed off.
     #
     set w1 NOT_SET
     scan $msg "%s %s %s %s"  w1 w2 w3 w4
     if { $w1 == "TOKEN" } {
          if { [llength $msg] == 4 } {
              TOKEN_FSM RECV_$w3 $w2 $w4
          } else {
              dputs "###     invalid TOKEN message - discarded"
          }
          return
     } elseif { $w1 == "BNS" } {
       if { [llength $msg] >= 3 } {
         parse_bns_message $w2 $w3 
       } else {
         dputs "###     invalid BNS message - discarded"
       }
       return
     } elseif { $w1 == "TRAP" } {
       if { [ llength $msg ] == 4 } {
              parse_trap_message $w2 $w3 $w4
          } else {
              dputs "###     invalid TRAP message ($msg) - discarded"
          }
          return
     } elseif { [llength $msg] == 2 } {
          if { [string compare $w1 $partname] == 0 } {
               if { [string compare $w2 "RESET"] == 0 } {
                    reset_all_item    
               } 
               # another message with 2 words is
               #  PARTname STATUS
               # This is for central (ctksup) not us.
          } 
          return
     } elseif { [llength $msg] == 3 } {
       #  PARTname PONG UNKNOWN
       # This is for central (ctksup) not us.
       if { [ string compare $w2 "PONG" ] == 0 && [ string compare $w3 "UNKNOWN" ] == 0 } {
         return
       }
     } elseif { [llength $msg] == 1 } {
          if { [string match "PONG*" $w1 ] == 1 } {
              ISUP_FSM RECV_PONG
          }
          return
     }
     # Any message beyond this point is from ISUP. Increment ISUP(COUNTER)
     # for ISUP_FSM.
     incr ISUP(COUNTER)

     # Check the status of the DRS partition if required
     if { [ DRS_isDrsPartition ] } {
       if { ! [ DRS_isStatusValid ] } {
         DRS_updateStatus
       }
     }
   

     # Part 2:
     #
     # If we are here, ten message/event has not been passed off - it is
     # a SNAPSHOT response or an event (status change) from ISUP.
     # Process it and update system status structures.
     #
     # Processing has changed as all status info for a node in on one line now.
     # Process each node's line and simulate original 1 line per device. Yuk
     #
     set numpar [llength $msg]
     set nodename [lindex $msg 0]
     set parn 1
     while { $numpar > $parn } {
         switch -- $parn {
             1 {  set msgtype 2
                  set itemname NULL
                  set status [lindex $msg 1]
                  incr parn
             }
             2 {  set msgtype 3
                  set itemname NULL
                  set status [lindex $msg 2]
                  incr parn
             }
             default {
                  set msgtype 4
                  set itemname [lindex $msg $parn]
                  set status [lindex $msg [expr $parn + 1]]
                  incr parn 2
         	  #puts "DEBUG: msgtype = \"$msgtype\", nodename = \"$nodename\", itemname = \"$itemname\", status = \"$status\", parn = $parn"
             }
         }
         dputs "DEBUG: msgtype = \"$msgtype\", nodename = \"$nodename\", itemname = \"$itemname\", status = \"$status\", parn = $parn"

         #
         # msgtype 2 -> Node status message
         ######################################################################
         if { $msgtype == 2 } {     
                if { [ string length [ info command $m.$nodename.bnode_$nodename ] ] == 0 } {

                     frame $m.$nodename -borderwidth 2 -relief raised -bg grey 
                     # this node is not yet displayed: add a button,
                     # and a sub-window for device display
                     incr nb_node
                     set nb_dev($nodename) 0
                     lappend node_list $nodename
                     set node($nodename) $nodename
##                        
                     # Initialize a new toplevel to display node items
                     toplevel .top$nodename -bg darkgrey
                     wm title .top$nodename "$partname / $nodename DEVICE STATES"
                     wm resizable .top$nodename false true
                     wm withdraw .top$nodename
                     wm protocol .top$nodename WM_DELETE_WINDOW "wm withdraw .top$nodename"

                     frame .top$nodename.f1 -borderwidth 5 -relief ridge -bg blue
                     pack .top$nodename.f1 -side top -fill both -expand 1

                     frame .top$nodename.f1.f2 -bd 2 -relief raised -bg darkgrey
                     pack .top$nodename.f1.f2 -side top -fill both -expand 1

                     scrollbar .top$nodename.f1.f2.cyscrol -orient vertical -bg darkgrey -command [list .top$nodename.f1.f2.c1 yview]
                     canvas .top$nodename.f1.f2.c1 -bg grey -yscrollcommand [list .top$nodename.f1.f2.cyscrol set] -bg grey
                     frame .top$nodename.f1.f2.c1.fn -borderwidth 2 -relief sunken -bg grey 
                     .top$nodename.f1.f2.c1 create window 0 0 -anchor nw -window .top$nodename.f1.f2.c1.fn 
    
                     label .top$nodename.f1.f2.lt -text "$nodename Device States" -bg darkgrey \
			                    -font $font14 -fg black
                     button .top$nodename.f1.f2.b1 -bg darkgrey -text "Close" -font $font12  \
                                             -command "wm withdraw .top$nodename"
                     pack .top$nodename.f1.f2.b1 -side bottom
                     pack .top$nodename.f1.f2.lt
                     pack .top$nodename.f1.f2.c1 -side left -fill both -expand 1 
                     pack .top$nodename.f1.f2.cyscrol -side right -fill y 
##
                     # Add a button for that node in the main window to visually
                     # indicate the state of the node
                     button $m.$nodename.bnode_$nodename  -relief sunken -bg darkgrey
                     $m.$nodename.bnode_$nodename configure -bitmap @$dat_dir/node.bmp -fg black

                     # Add a triangle type button to the main window, which will display
                     # the list of devices associated to that node on a mouse click
                     button $m.$nodename.bnodeTRI$nodename -bg darkgrey -relief raised 
                     $m.$nodename.bnodeTRI$nodename configure -bitmap @$dat_dir/tri.bmp -fg black
                     bind $m.$nodename.bnodeTRI$nodename <ButtonRelease-1> \
                          "dev_win_state_command .top$nodename"

                     label $m.$nodename.lnode1_$nodename -text $nodename -width 16 -bg grey \
				                         -font $font14 -fg black
                     label $m.$nodename.lnode_$nodename -text " " -width 16  -bg grey \
				                        -font $font14 -fg black
                     label $m.$nodename.ldnode_$nodename -text " " -width 26 -bg grey \
                                                         -font $font14 -fg black -anchor nw

                     grid $m.$nodename.bnode_$nodename   -row $nb_node  -column 0 -padx 10
                     grid $m.$nodename.bnodeTRI$nodename -row $nb_node  -column 1
                     grid $m.$nodename.lnode1_$nodename  -row $nb_node  -column 2
                     grid $m.$nodename.lnode_$nodename   -row $nb_node  -column 3
                     grid $m.$nodename.ldnode_$nodename  -row $nb_node  -column 4
                
                     if { $first_column } {
                          grid $m.$nodename -row $nb_node -column 0
                          set first_column 0
                     } else {
                          grid $m.$nodename -row [expr $nb_node - 1] -column 1
                          set first_column 1
                     }
		     LOG_write "NodeState    :  $state(${msgtype}_${status})    received for node $nodename" [ determineNodeStateAlert $state(${msgtype}_${status}) ]
                }

                if { $numpar < 5 } {
                           LOG_write "NodeState    :  $state(${msgtype}_${status})    received for node $nodename" [ determineNodeStateAlert $state(${msgtype}_${status}) ] 
                }

                # configure the node color and print out appropriate state of node
                $m.$nodename.bnode_$nodename configure -background $color(${msgtype}_${status}) \
                    -activebackground $color(${msgtype}_${status})
                $m.$nodename.lnode_$nodename configure -text $state(${msgtype}_${status}) 
                 
                # if an ONLINE state is received for a node which has one or more devices in a NOT OK
                # state and not OPERATIONAL, then this node is said to be in a "degraded mode",
                # hence its colour should reflect this by using yellow as the node state colour

                upvar #0 dev_state_of_items_$nodename a
                foreach el [array names a] {
                   if {[string compare $a($el) "100"] != 0} {
			if { [string compare $a($el) "109"] == 0 || \
                            [string compare $a($el) "102"] == 0 || \
                            [string compare $a($el) "108"] == 0 || \
                            [string compare $a($el) "111"] == 0} {
				continue
			} else {	
		   	  # there is at least one device which it NOT OK and not in OPERATIONAL state so
			  # the overall node state must be "degraded"
			  # Set the node color to (yellow)
                       	  if {[string compare $state(${msgtype}_${status}) $state(2_23)] == 0}  {
                            	 $m.$nodename.bnode_$nodename configure -background $color(2_21) \
                          	            -activebackground $color(2_21)
                       	  }
                          break
		        }
                   }
		}
         #
         # msgtype 3 -> DNC status message
         ######################################################################
         } elseif { $msgtype == 3 } {
                # dual node status 
                # 52 represents BS_DNCMASTER
                # 53 represents BS_DNCSLAVE
                # 51 represents DNCSINGLE 
                # 55 represents DNCRUNDOWN

                # remove nodes from dual node list when becomes single or rundown
                if { $status == 51 || $status == 55 } {
                  set index [ lsearch -exact $dual_node_list $nodename ]
                  if {  $index >= 0  } {
                    set dual_node_list [ lreplace $dual_node_list $index $index ]
                  }
                # add nodes to dual node list when becomes master or slave 
                } elseif { $status == 52 || $status == 53 } {
                  if { [ lsearch -exact $dual_node_list $nodename ] == -1 } {
                    lappend dual_node_list $nodename
                  }
                } 
                $m.$nodename.ldnode_$nodename configure -text $state(${msgtype}_${status}) 
                LOG_write "DualNodeState:  $state(${msgtype}_${status}) received for node $nodename" I
         #
         # msgtype 4 -> Device state message
         ######################################################################
         } elseif { $msgtype == "4" } {
                if { $itemname == "SCM_STORE" } {
                      # skip SCM_STORE failures - ISUP node going down.
                       continue
                }
                if { $itemname == "fp" || $itemname == "global_lan1" || $itemname == "X25_CNF_FP1" } {
                      # skip these SYS_LAN_MNG devices as always UNKNOWN
                       continue
                }
                LOG_write "DevState     :  $state(${msgtype}_${status})     received for item $itemname on node $nodename" \
                         [ determineDeviceStateAlert $state(${msgtype}_${status}) ] 

                # Get the LAN state
                if { $LAN(NODES) != {} } {
                  if { [ string match "OPS_eth?" $itemname ] } {
                    if { [ lsearch -exact $LAN($nodename,OPS) $itemname ] == -1 } {
                      lappend LAN($nodename,OPS) $itemname
                    }
                    set LAN($nodename,OPS,$itemname) $status
                  } 
                  if { [ string match "SRV_eth?" $itemname ] } {
                    if { [ lsearch -exact $LAN($nodename,SRV) $itemname ] == -1 } {
                      lappend LAN($nodename,SRV) $itemname
                    }
                    set LAN($nodename,SRV,$itemname) $status
                  } 
                }

                if { [ string compare $itemname "GLB_CLOCK" ] == 0 } {
                  #
                  # We display two states for the GLOBAL_CLOCK - its either connected and synchronised or it isnt!
                  # So display green if the current state is OPERATIONAL, red otherwise (ignoring "UNKNOWN" state of course)
                  #                       Local device
                  #                       ------------
                  #
                  #                       No External I/F   External I/F Failed   External I/F OK
                  #
                  #       Synchronized    OK                READY                 OPERATIONAL
                  #       Unsynchronized  FAILED            NOT_OK                STANDBY
                  #
                  #                       Global device
                  #                       -------------
                  #
                  #                       No External I/F
                  #                       or External I/F Failed   External I/F OK
                  #
                  #       Synchronized    OK                       OPERATIONAL
                  #       Unsynchronized  FAILED                   STANDBY
                  #
                  if { $status != 102 } {   # UNKNOWN
                    if { $status == 109 } {   # OPERATIONAL
                      .wfm.fgclock.lgclock configure -bg green
                    } elseif  { $status == 100 } {
                      .wfm.fgclock.lgclock configure -bg yellow
                    } else {
                      .wfm.fgclock.lgclock configure -bg red
                    }
                  }
                }

                set t .top$nodename.f1.f2.c1.fn
                global dev_state_of_items_$nodename 

                if {[string length [info command $t.bdev_$itemname]] == 0} {
                        global dev_$nodename  dev_list_$nodename
                        set dev_${nodename}($itemname) $itemname
                        upvar #0 dev_state_of_items_$nodename a
                        set a($itemname) $status
                        lappend dev_list_$nodename $itemname

                        incr nb_dev($nodename)
		        	
                        button $t.bdev_$itemname  -relief sunken -fg blue
			set local_nodename $nodename

                        button $t.bdev_ext$itemname -bitmap @$dat_dir/external.bmp
                        bind  $t.bdev_ext$itemname <Button-1> { attach_detach_line  %W }

                        $t.bdev_$itemname configure -bitmap @$dat_dir/dev.bmp
                        label $t.ldev1_$itemname -text $itemname  -width 20 -bg grey -font $font14 -fg black 
                        label $t.ldev_$itemname -text "         " -width 20 -bg grey -font $font14 -fg black 

			set can_detach 0
			# Determine whether to put a button on the device or not - the button allows
			# the user to detach the device (if UBSS allows it).
			set lst "CPU DISK GLB_CLOCK LOC_CLOCK MEMORY NETWORK local_lan1 FP_MEM_SHARED"
                        if { [ lsearch -exact $lst $itemname ] == -1 } {
			  if { [ string compare $itemname "AFTN" ] == 0 || \
                               [ string match "OLDI*" $itemname ] == 1 || \
                               [ string match "COOR*" $itemname ] == 1 || \
                               [ string match "ADEXP*" $itemname ] == 1 || \
                               [ string match "ETMS" $itemname ] == 1 || \
                               [ string match "EXT_FDP*" $itemname ] == 1 || \
                               [ string match "RADAR_\[0-9\]\[0-9\]_\[1-4\]" $itemname ] == 1 || \
                               [ string match "WAM_\[0-9\]\[0-9\]_\[1-4\]" $itemname ] == 1 || \
                               [ string match "ARINC_LINE_*" $itemname ] == 1 || \
                               [ string match "SITA_LINE_*" $itemname ] == 1 || \
                               [ string match "TCP_\[0-9\]" $itemname ] == 1 || \
                               [ string match "R_OCP_\[0-9]\[0-9\]_\[1-4\]" $itemname ] == 1 || \
                               [ string match "AFP_LN_\[0-9\]_\[1-2\]" $itemname ] == 1 || \
                               [ string match "AFP_LN_\[0-9\]\[0-9\]_\[1-2\]" $itemname ] == 1 || \
                               [ string match "AFB_LN_\[0-9\]_\[1-2\]" $itemname ] == 1 || \
                               [ string match "AFB_LN_\[0-9\]\[0-9\]_\[1-2\]" $itemname ] == 1 || \
                               [ string match "TCP_HARRIS" $itemname ] == 1 || \
                               [ string match "STPRINT*" $itemname ] == 1 } {
			    set can_detach 1
                          }
  			}
                        if { $can_detach == 1 } {
                            grid $t.bdev_ext$itemname -row $nb_dev($nodename) -column 0
                        } else {
                            grid $t.bdev_$itemname -row $nb_dev($nodename) -column 0
                        }

                        grid $t.ldev1_$itemname -row $nb_dev($nodename) -column 1
                        grid $t.ldev_$itemname -row $nb_dev($nodename) -column 2

                        # Special processing : if there is a <partition>_radar file available - put the radar name instead of "RADAR_01" etc
                        if { [ llength $DATA(RADAR) ] > 0 } {
                          if { [ string match "RADAR_*" $itemname ] } {
                            # Get the radar number, use this as the index into the file. If the index is beyond the end of the file, or the 
                            # file entry is "#" then just use the text sent from ISUP, otherwise use the file name
                            set posA [ string first "_" $itemname ]
                            set posB [ string last "_" $itemname ]
                            if { $posA == $posB }  {
                              regexp {^0*(\d+)$} [ string range $itemname [ expr $posA + 1 ] end ] _dummy index
                              incr index -1
                              set rname [ lindex $DATA(RADAR) ${index} ]
                              set oname ""
                            } else {
                              regexp {^0*(\d+)$} [ string range $itemname [ expr $posA + 1 ] [ expr $posB - 1 ] ] _dummy index
                              incr index -1
                              set rname [ lindex $DATA(RADAR) ${index} ]
                              set oname [ string range $itemname $posB end ]
                            } 
                            if { $rname != "" && $rname != "*" } {
                              $t.ldev1_$itemname configure -text $rname$oname
                            }
                          }
                        # Special processing : if there is a <partition>_radar file available - put the radar name instead of "R_OPC_01_1" etc
                          if { [ string match "R_OCP_*" $itemname ] } {
                            # Get the radar number, use this as the index into the file. If the index is beyond the end of the file, or the 
                            # file entry is "#" then just use the text sent from ISUP, otherwise use the file name
                            set posA [ string first "_" $itemname 3 ]
                            set posB [ string last "_" $itemname ]
                            if { $posA == $posB }  {
                              regexp {^0*(\d+)$} [ string range $itemname [ expr $posA + 1 ] end ] _dummy index
                              incr index -1
                              set rname [ lindex $DATA(RADAR) ${index} ]
                              set oname ""
                            } else {
                              regexp {^0*(\d+)$} [ string range $itemname [ expr $posA + 1 ] [ expr $posB - 1 ] ] _dummy index
                              incr index -1
                              set rname [ lindex $DATA(RADAR) ${index} ]
                              set oname [ string range $itemname $posB end ]
                              set fname "OCP_${rname}"
                            } 
                            if { $rname != "" && $rname != "*" } {
                              $t.ldev1_$itemname configure -text $fname$oname
                            }
                          }
                        }
                        # Special processing : if there is a <partition>_adsb file available - put the adsb name instead of "AFB_01" etc
                        if { [ llength $DATA(AFB) ] > 0 } {
                          if { [ string match "AFB_*" $itemname ] } {
                            # Get the adsb number, use this as the index into the file. If the index is beyond the end of the file, or the 
                            # file entry is "#" then just use the text sent from ISUP, otherwise use the file name
                            set posA [ string first "_" $itemname ]
                            set posB [ string last "_" $itemname ]
                            if { $posA == $posB }  {
                              regexp {^0*(\d+)$} [ string range $itemname [ expr $posA + 1 ] end ] _dummy index
                              incr index -1
                              set rname [ lindex $DATA(AFB) ${index} ]
                              set oname ""
                            } else {
                              regexp {^0*(\d+)$} [ string range $itemname [ expr $posA + 1 ] [ expr $posB - 1 ] ] _dummy index
                              incr index -1
                              set rname [ lindex $DATA(AFB) ${index} ]
                              set oname [ string range $itemname $posB end ]
                            }
                            if { $rname != "" && $rname != "*" } {
                              $t.ldev1_$itemname configure -text $rname$oname
                            }
                          } 
                        }

                #keep a copy of the corresponding state for the item in the current node
                #
                upvar #0 dev_state_of_items_$nodename a
                set a($itemname) $status
                $t.bdev_$itemname configure -background $color(${msgtype}_${status}) \
                        -activebackground $color(${msgtype}_${status}) 

                $t.bdev_ext$itemname configure -background $color(${msgtype}_${status}) \
                        -activebackground $color(${msgtype}_${status}) 

                $t.ldev_$itemname configure -text $state(${msgtype}_${status}) \
			-font $font14 
                
                # Extract the background color & state of the current node
                #
                set node_color {$m.$nodename.bnode_$nodename cget -background}
                set node_state {$m.$nodename.lnode_$nodename cget -text}

                # check to is if the item state is anything but OK
                # further check to see if the node corresponding to this item
                # is in an ONLINE state by using the background color,if so this
                # node is now in a degraded state, hence change the
                # node color to "yellow"
                #
		set degraded 0
                foreach el [array names a] {
                   if {[string compare $a($el) "100"] != 0} {
			if { [string compare $a($el) "109"] == 0 || \
                            [string compare $a($el) "102"] == 0 || \
                            [string compare $a($el) "108"] == 0 || \
                            [string compare $a($el) "111"] == 0 || \
                            [string compare $a($el) "42"] == 0 } {
				continue
			} else {	
		   	  # there is at least one device which it NOT OK and not in OPERATIONAL state so
			  # the overall node state must be "degraded"
			  # Set the node color to (yellow)
                   	  if {[string compare [eval $node_state] $state(2_23)] == 0}  {
                      		$m.$nodename.bnode_$nodename configure -background $color(2_21) \
                       	     		-activebackground $color(2_21)
				set degraded 1
                   	  }
                          break
		        }
                   }
		}
	        if { $degraded == 0 } {
                   if {[string compare [eval $node_state] $state(2_23)] == 0}  {
                                $m.$nodename.bnode_$nodename configure -background $color(2_23) \
                          	           -activebackground $color(2_23)
                 }
	    }
         }
     }
} 
  #
  # Allow update to get device states and main frame sizes to set their canvases to correct sizes.
  #
  update idletasks

  set w [ winfo width .top$nodename.f1.f2.c1.fn ]
  set h [ winfo height .top$nodename.f1.f2.c1.fn ]

  if { $h < $max_height_devs } {
    .top$nodename.f1.f2.c1 configure -width $w -height $h -scrollregion "0 0 $w $h"
  } else {
    .top$nodename.f1.f2.c1 configure -width $w -height $max_height_devs -scrollregion "0 0 $w $h"
  }

  set w [ winfo width .c.f ]
  if { $w < $min_width_nodes } {
    set w $min_width_nodes
  }
  set h [ winfo height .c.f ]
  if  { $h < $min_height_nodes } {
    set h $min_height_nodes
  }
  if { $h < $max_height_nodes } {
    .c configure -width $w -height $h -scrollregion "0 0 $w $h"
  } else {
    .c configure -width $w -height $max_height_nodes -scrollregion "0 0 $w $h"
  }
}

#-------------------------------------------------------------------------------------

proc ISUP_statusIndicator { win } {
 
  dputs "### ISUP_statusIndicator: $win"

  frame $win.fisup -bd 2 -bg grey -relief ridge
  pack $win.fisup -side right
 
  label $win.fisup.labeltxt -text "ISUP:" -fg blue4 -bg grey
  pack $win.fisup.labeltxt -side left -ipady 1
 
  label $win.fisup.lisup -text "" -bd 1 -relief solid -bg yellow 
  pack $win.fisup.lisup -side left -ipadx 10 -padx 3
 
} 

#-----------------------------------------------------------------------
#  isup Finite State Machine
#
#  Handles interaction with system ISUP process. 
#-----------------------------------------------------------------------

proc ISUP_FSM { isupEvent } {
     global time_str
     global ISUP

     dputs "### ISUP_FSM: $isupEvent"
     dputs "###     isupState($ISUP(STATE))  isupCounter($ISUP(COUNTER)) isupRetries: $ISUP(RETRIES)"

     set nextState $ISUP(STATE)
     switch -- $ISUP(STATE) {
         RED {
            switch -- $isupEvent {
               RECV_PONG {
                   after cancel $ISUP(TIMERID)
                   set ISUP(COUNTER) 0
                   set ISUP(RETRIES) $ISUP(MAXTRIES)
                   puts $ISUP(STREAM) "PING  "
                   flush $ISUP(STREAM)
                   set nextState GREEN
                   set ISUP(TIMERID) [ after $ISUP(LONGTIME) ISUP_FSM TIMER_EXPIRED ]
                   reset_all_item
               }
               TIMER_EXPIRED {
                   if { $ISUP(COUNTER) > 0 } {
                       set ISUP(COUNTER) 0
                       set ISUP(RETRIES) $ISUP(MAXTRIES)
                       set nextState GREEN
                       set ISUP(TIMERID) [ after $ISUP(LONGTIME) ISUP_FSM TIMER_EXPIRED ]
                       reset_all_item
                   } else {
                       if { $ISUP(RETRIES) > 0 } {
                          incr ISUP(RETRIES) -1
                          puts $ISUP(STREAM) "PING "
                          flush $ISUP(STREAM)
                          set ISUP(TIMERID) [ after $ISUP(SHORTTIME) ISUP_FSM TIMER_EXPIRED ]
                       } else {
                          set ISUP(RETRIES) $ISUP(MAXTRIES)
                          set ISUP(TIMERID) [ after $ISUP(LONGTIME) ISUP_FSM TIMER_EXPIRED ]
                       }
                   }
               }
            }
         }
         YELLOW {
            switch -- $isupEvent {
               RECV_PONG {
                   after cancel $ISUP(TIMERID)
                   set ISUP(COUNTER) 0
                   set ISUP(RETRIES) $ISUP(MAXTRIES)
                   set nextState GREEN
                   set ISUP(TIMERID) [ after $ISUP(LONGTIME) ISUP_FSM TIMER_EXPIRED ]
                   reset_all_item
               }
               TIMER_EXPIRED {
                   if { $ISUP(COUNTER) > 0 } {
                       set ISUP(COUNTER) 0
                       set ISUP(RETRIES) $ISUP(MAXTRIES)
                       set nextState GREEN
                       set ISUP(TIMERID) [ after $ISUP(SHORTTIME) ISUP_FSM TIMER_EXPIRED ]
                       reset_all_item
                   } else {
                       if { $ISUP(RETRIES) > 0 } {
                          incr ISUP(RETRIES) -1
                          puts $ISUP(STREAM) "PING "
                          flush $ISUP(STREAM)
                          set ISUP(TIMERID) [ after $ISUP(SHORTTIME) ISUP_FSM TIMER_EXPIRED ]
                       } else {
                          set ISUP(RETRIES) $ISUP(MAXTRIES)
                          set nextState RED
                          set ISUP(TIMERID) [ after $ISUP(SHORTTIME) ISUP_FSM TIMER_EXPIRED ]
                          reset_all_item
                       }
                   }
               }
            }
         }
         GREEN {
            switch -- $isupEvent {
               RECV_PONG {
                   after cancel $ISUP(TIMERID)
                   set ISUP(COUNTER) 0
                   set ISUP(RETRIES) $ISUP(MAXTRIES)
                   set ISUP(TIMERID) [ after $ISUP(LONGTIME) ISUP_FSM TIMER_EXPIRED ]
               }
               TIMER_EXPIRED {
                   if { $ISUP(COUNTER) > 0 } {
                      set ISUP(COUNTER) 0
                      set ISUP(RETRIES) $ISUP(MAXTRIES)
                      set ISUP(TIMERID) [ after $ISUP(LONGTIME) ISUP_FSM TIMER_EXPIRED ]
                   } else {
                       if { $ISUP(RETRIES) > 0 } {
                          incr ISUP(RETRIES) -1
                          puts $ISUP(STREAM) "PING "
                          flush $ISUP(STREAM)
                          set ISUP(TIMERID) [ after $ISUP(SHORTTIME) ISUP_FSM TIMER_EXPIRED ]
                      } else {
                          puts $ISUP(STREAM) "PING "
                          flush $ISUP(STREAM)
                          set ISUP(RETRIES) $ISUP(MAXTRIES)
                          set nextState YELLOW
                          set ISUP(TIMERID) [ after $ISUP(SHORTTIME) ISUP_FSM TIMER_EXPIRED ]
                      }
                   }
               }
           }
        }
     }
     dputs "###     nextState: $nextState  ISUP(COUNTER): $ISUP(COUNTER) ISUP(RETRIES): $ISUP(RETRIES)"
     if { $nextState != $ISUP(STATE) } {
        switch -- $nextState {
           GREEN  { 
               set logmsg "ISUP process connection OK" 
               set logmsgstate I
           }
           YELLOW { 
               set logmsg "ISUP process connection Recovery" 
               set logmsgstate I
           }
           RED    { 
               set logmsg "ISUP process connection Failed" 
               set logmsgstate F
           }
        }
        LOG_write "$logmsg" $logmsgstate
     }
     set ISUP(STATE) $nextState
     if { [string length [info command .wfm.fisup.lisup] ] != 0} {
        switch -- $ISUP(STATE) {
           GREEN  { .wfm.fisup.lisup configure -bg green }
           YELLOW { .wfm.fisup.lisup configure -bg yellow }
           RED    { .wfm.fisup.lisup configure -bg red }
        }
     }
}

#-----------------------------------------------------------------------------

proc determineTimeToWait { } {

  dputs "### determineTimeToWait:"

  regexp {^0*(\d+)$} [ clock format [ clock seconds ] -format "%H" ] _dummy hour
  regexp {^0*(\d+)$} [ clock format [ clock seconds ] -format "%M" ] _dummy min
  regexp {^0*(\d+)$} [ clock format [ clock seconds ] -format "%S" ] _dummy sec

  # calculate total time in seconds
  set current_time_in_sec [ expr ( ( $hour * 60 + int($min) ) * 60 ) + int($sec) ]
  set twenty_four_hour_in_sec [ expr 24 * 60 * 60 ]

  set time_to_wait [ expr ( $twenty_four_hour_in_sec - $current_time_in_sec ) * 1000 ]

  dputs "Time to wait : $time_to_wait"
  return $time_to_wait
}

#-----------------------------------------------------------------------------
proc LOG_switchLogFileStream { } {
  global LOG

  if { $LOG(STREAM) != -1 } {
    close $LOG(STREAM)
  }
  set LOG(STREAM) $LOG(STREAM_NEW)
  set LOG(STREAM_NEW) -1
}

#-----------------------------------------------------------------------------

proc LOG_reopenLogFile { } {

  dputs "### LOG_reopenLogFile:"

  LOG_openLogFile
  LOG_switchLogFileStream
}
#======================================================================================
# LOG FILE HANDLING
#========================================================================================
# ------------------------------------------------------------------------------
#    Create Log file
#
#    the following conventions will be used to log the output of the supervision tool
#    1. create a seperate circular file for each day of the week
#    2. The eighth day will be overridden to the 1st days file.
#
#--------------------------------------------------------------------------------------
proc LOG_openLogFile { } {
  global log_dir exe_name partname
  global LOG

  dputs "### LOG_openLogFile:"

  set dayOfMonth [ clock format [ clock seconds ] -format "%d" ]
  set dayOfWeek [ clock format [ clock seconds ] -format "%u" ]
  set fileName "${exe_name}_log_${partname}_${dayOfWeek}"

  if { ! [ file exist ${log_dir}/${fileName} ] } {
    set appendfile 0
  } else {
    # Open the file, check the first line for the "#FILE_CREATED" time.
    # if this doesnt exist, or the timestamp is not current then truncate the file, otherwise append
    set LOG(STREAM_NEW) [ open ${log_dir}/${fileName} r ]
    set filecreate [ gets $LOG(STREAM_NEW) ]
    close $LOG(STREAM_NEW)
    if { [ string compare -length [ string length "#FILE_CREATED" ] $filecreate "#FILE_CREATED" ] == 0 } {
      set timestamp [ string trim [ string range $filecreate [ string last " " $filecreate ] end ] ]
      set currenttimestamp  [ clock format [ clock seconds ] -format "%d/%m/%y"]
      if { [ string compare $timestamp $currenttimestamp ] == 0 } {
        # timestamp is good - append!
        set appendfile 1
      } else {
        # timestamps is bad - truncate
        set appendfile 0
      }
    } else {
      # no timestamp - truncate
      set appendfile 0
    }
  }
  if { $appendfile == 1 } {
    puts "append to file $fileName"
    set LOG(STREAM_NEW) [ open ${log_dir}/${fileName} a ]
  } else {
    puts "re-create file $fileName"
    set LOG(STREAM_NEW) [ open ${log_dir}/${fileName} w ]
    puts $LOG(STREAM_NEW) "#FILE_CREATED: [ clock format [ clock seconds ] -format "%H:%M:%S %d/%m/%y"]"
  } 
  set time_to_wait [ determineTimeToWait ]
  after $time_to_wait LOG_reopenLogFile
}

#======================================================================================
# MAIN 
#========================================================================================
# ------------------------------------------------------
# define fonts
# ------------------------------------------------------

set font12cour -*-courier-bold-r-normal-*-12-*-*-*-*-*-*
set font14cour -*-courier-bold-r-normal-*-14-*-*-*-*-*-*
set font12hel -*-helvetica-bold-r-normal-*-12-*-*-*-*-*-*
set font14hel -*-helvetica-bold-r-normal-*-14-*-*-*-*-*-*
#set font12 -*-times-bold-r-normal-*12-*-*
#set font14 -*-times-bold-r-normal-*14-*-*
#set font18 -*-times-bold-r-normal-*18-*-*
set font12 -*-arial-bold-r-normal-*12-*-*
#set font14 -*-arial-bold-r-normal-*14-*-*
set font14 -misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-9
set font18 -*-arial-bold-r-normal-*18-*-*
set font22 -*-times-bold-r-normal-*22-*-*
set font24 -*-times-bold-r-normal-*24-*-*


#-------------------------------------------------------------------------------
#  global variable declaration
#-------------------------------------------------------------------------------

set m .c.f
set nb_node 0
set max_height_devs 400
set max_height_nodes 400
set min_width_nodes 950
set min_height_nodes 200
set cmd_window_inuse 0
set switch_node_inuse 0
set snmp_inuse 0

#-------------------------------------------------------------------------------
#  token control variables 
#-------------------------------------------------------------------------------

set TOKEN(TIMERID)        {}
set TOKEN(STATE)          QUERYING
set TOKEN(COUNTER)        0
set TOKEN(RETRYTIME)      3000
set TOKEN(MAXTRIES)       3
set TOKEN(STREAM)         {}

#-------------------------------------------------------------------------------
#  ISUP_FSM control variables 
#-------------------------------------------------------------------------------

set ISUP(TIMERID)        {}
set ISUP(STATE)          YELLOW
set ISUP(COUNTER)        0
set ISUP(LONGTIME)       10000
set ISUP(SHORTTIME)      1000
set ISUP(MAXTRIES)       3
set ISUP(RETRIES)        $ISUP(MAXTRIES)

#-------------------------------------------------------------------------------
#
#-------------------------------------------------------------------------------
set recNodes_inuse 0
set physical_mon_inuse 0
set first_column 1
set node_list {}
set dual_node_list {}

set LOG(F,PRINT)     0
set LOG(F,LOG)       1
set LOG(F,ONLINE)    1
set LOG(W,PRINT)     0
set LOG(W,LOG)       1
set LOG(W,ONLINE)    1
set LOG(I,PRINT)     0
set LOG(I,LOG)       1
set LOG(I,ONLINE)    0
set LOG(STREAM)      -1
set LOG(STREAM_NEW)  -1

set DRS(PARTITION)              0
set DRS(STATUS)                 -1
set DRS(ISUPNODE)               "localhost"
set DRS(LABEL)                  {}

set REC(AVAILABLE)              -1
set REC(PATH)                   {}

set PRIV(STATE)                 0
set PRIV(TOPLEVEL)              ""

set REC(AVAILABLE)              0
set REC(DIR)                    ""

set MUTED(STATE)                -1
set MUTED(NEWSTATE)             -1

set LAN(DISPLAY)                -1
set LAN(STREAM)                 -1
set LAN(STREAM_PID)             -1

set SW_DATA(DISPLAY)            -1

set MODE(CURRENT_MODE)          UNKNOWN
set MODE(DISPLAY)               -1
set MODE(STATE)                 INIT
set MODE(STREAM)                -1
set MODE(STREAM_PID)            -1
set MODE(SYSREF_HOST)           192.168.59.3

set SYSMON(DISPLAY)             -1
set SYSMON(STREAM)              -1
set SYSMON(STREAM_PID)          -1

set HANDLE(DISPLAY)             -1
set HANDLE(STR,HANDLE_NEW)    "SYS_MNG HANDLE_NEW_DISTRIBUTION"
set HANDLE(STR,RESTART_NEW)   "SYS_MNG RESTART_WITH_NEW_PARAMETERS"
set HANDLE(STR,HANDLE_PREV)   "SYS_MNG HANDLE_PREVIOUS_DISTRIBUTION"
set HANDLE(STR,FAIL_1)        "ISCM_CMD_FAILED"
set HANDLE(STR,FAIL_2)        "Command not available"
set HANDLE(STR,SUCCESS)       "ISCM_CMD_EXECUTED"
set xpath  /usr/bin/X11/xterm
set data_central_node   0
set hnd_flag            0 

set DISCOVER(DISPLAY)        -1
set DISCOVER(STREAM)         -1
set DISCOVER(STREAM_PID)     -1
set DISCOVER(BSLAN_MONITOR)  /opt/system/PcvCurrent/CONFM_EXE_UBSS/ubss_bin/bslan_monitor

set ALARM(ON)           1
set ALARM(COUNT)        -1

set PRINT(VALIDNODE)    0   ; # by default set to off 
set PRINT(NODE)         ""
set PRINT(CUPS)         0   ; # is this a CUPS printer? 
set PRINT(CUPS_NAME)    ""

set rcmd "/bin/ssh -o ConnectTimeout=40 -o LogLevel=Error -o ServerAliveInterval=40 -o BatchMode=yes -T -x "


# -------------------------------------------------------------------------- 
#
# ------------------------------------------------------------------------------
 
set localIdent  [exec hostname]:[pid]

set suffix $env(service_lan_suffix)

# Add a check on the DISPLAY variable as it may not be correctly set!
if { [ catch { set display $env(DISPLAY) } msg ] == 1 } {
  puts "\n\nError! Cannot read \$DISPLAY environment variable. Please set this variable and restart\n"
  exit
}
if { [ string match {:0.0} $display ] || [ string match {:0} $display ] } {
  # limited display variable - this will cause issues opening up programs on remote nodes, so use the localhostname instead
  set display [exec hostname]:0.0
}
puts "display set to ($display)"
set isup_lan $env(ISUP_LAN)

#--------------------------------------------------------------------------------------
# create partition port and mcast address variables to be used for input 
# and output messages.
#--------------------------------------------------------------------------------------

defineColorStateAttributes

defineExecutionEnvironment

readOfflineFiles

LOG_reopenLogFile
puts $LOG(STREAM) "\n\n[pid]Start of Tksup Processing on $partname @ [ clock format [ clock seconds ] -format "%H:%M:%S %d/%m/%y" ]\n\n"
puts $LOG(STREAM) "[pid]DISPLAY set to ($display)"
#--------------------------------------------------------------------------------------

wm title . "$partname / TopSky-ATC(HE) Technical Supervision"
wm geometry . +0+0
wm resizable . false true
wm protocol . WM_DELETE_WINDOW doExit

Menu_Bar .wfm

canvas .c -yscrollcommand [list .yscroll set] -width $min_width_nodes \
        -height $min_height_nodes -highlightthickness 0 -borderwidth 0 -bg grey 
frame .c.f -bd 0 -bg grey
scrollbar .yscroll -orient vertical -bg darkgrey -command [list .c yview]
.c create window 0 0 -anchor nw -window .c.f

Message_Window .p

Action_Buttons .a

grid .wfm -column 0 -columnspan 2 -sticky ew 
grid .c  -row 1 -column 0 -sticky news
grid .yscroll -row 1 -column 1 -sticky nes
grid .p -row 2 -column 0 -columnspan 2 -sticky news
grid .a -row 3 -column 0 -columnspan 2 -sticky ew
grid rowconfigure . 1 -weight 3
grid rowconfigure . 2 -weight 1

LAN_initMonitorNodes

#--------------------------------------------------------------------------------------
# open input and output pipes for ports ISUPC, ISUPR and TOKEN
# attach event hanlder to input
#--------------------------------------------------------------------------------------
# "-s" option for mcat prepends the sending node name to the received string
set ISUP(STREAM)  [open "|$exe_dir/mcat -t 10 -p $portisupc -w $mcastiface -m $mcastaddr" w]
set TOKEN(STREAM) [open "|$exe_dir/mcat -t 10 -p $porttoken -w $mcastiface -m $mcastaddr" w]
set mcat_input_stream [open "|$exe_dir/mcat -s -r $portisupr -m $mcastaddr -r $porttoken -m $mcastaddr" r]
fileevent $mcat_input_stream readable {parse_msg [gets $mcat_input_stream] }

#-----------------------------------------------------------------------------------------
# Kickstart activity of tksup
#-----------------------------------------------------------------------------------------

ISUP_FSM  TIMER_EXPIRED
TOKEN_FSM TIMER_EXPIRED $partname $localIdent

MODE_determineCurrentMode

# Start the alarm loop
ALARM_ring

#=================================================================================
# END
#=================================================================================
